{"meta":{"title":"知识追寻者个人博客","subtitle":"你能看见山，你能看见海，你能看见这个世界的一切，我就不一样，我目光比较短浅，只能看见你","description":"","author":"lsc","url":"https://zszxz.github.io","root":"/"},"pages":[{"title":"关于知识追寻者","text":"知识追寻者毕业于2018年，至今n年，每天为生存而奋斗，为自由而读书，为社会国家进步而传播知识； 知识追寻者热衷于学习分享内容，探索未知的知识领域，发现新知识，在我的公众号有更多关于我的内容，希望大家支持；","path":"about/index.html","date":"11-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-05","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"11-05","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"11-05","excerpt":""}],"posts":[{"title":"redis持久化（九）","text":"持久化介绍redis 提供了两种方式方式进行数据的持久化（将数据存储到硬盘中）；第一种称为快照（snapshotting）RDB，它将某一时刻的所有数据都写入硬盘，所以快照是一次全量备份，并且存储的数据形式是二进制序列化形式；另一种方式是只追加文件（append-only file）AOF, 它会在执行命令时将命令复制一份到硬盘中，AOF在长期运行中会变的非常庞大，数据库重启加载AOF日志将会很慢； redis 将数据持久化的主要原因就是重用数据，或者防止系统故障，备份数据； 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据 工作原理快照工作原理redis的快照必须要求文件IO操作，单线程的redis进行多余的IO操作会影响服务器的性能，所以redis采用COW（copy on write）机制实现快照的持久化； 首先redis进行会fork一个子进程，此时就存在父子进程； 父进程负责进行修改操作，内存持续增加；而子进程数据不做任何变化； 子进程将瞬间数据写入磁盘的rdb文件 AOF工作原理AOF日志存放了redis指令顺序序列；所以只要重新执行AOF文件包含所有的命令就可以实现AOF文件记录的所有数据； 常用配置RDB配置默认文件 12dbfilename dump.rdbdir ./ redis会将数据默认dump至dump.rdb文件中；我们可以通过配置修改dump的频率； 123456#在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 900 1 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 300 10 #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照save 60 10000 如果想要禁用快照功能，注释掉如上配置，开启save &quot;&quot; 配置 1234save &quot;&quot;#save 900 1#save 300 10#save 60 10000 手动备份 save命令是阻塞命令 ,当服务器接收到save命令之后就会开始拍摄快照，在此期间不会处理其他请求; bgsave命令也是立即拍摄快照,非阻塞命令，而是fork一个子线程进行备份快照; 缺点 每隔一段时间进行一次持久化，如果redis崩溃，可能会导致部分数据丢失问题； RDB使用fork()子进程进行数据的持久化，如果数据量大，可能花费的时间较长，redis会造成明显的卡顿几秒现象； 很好的备份效果，容易进行数据恢复； 优点 相比AOF，在数据量比较大的情况下，RDB的启动速度更快； RDB使用fork()子进程进行数据的持久化，本身不会有多余的IO操作； AOF配置启用AOF 1appendonly yes 默认文件 12appendfilename &quot;appendonly.aof&quot;dir ./ fsync 如果redis发生宕机事件，有可能没来的及数据写入磁盘；此时redis AOF 的 fsync 策略能够保证redis保持高性能，和尽可能的减少数据丢失；默认就是使用 1s执行一次同步； 123456#每次有数据修改发生时都会写入AOF文件。#appendfsync always #每秒钟同步一次，该策略为AOF的缺省策略。appendfsync everysec #从不同步。高效但是数据不会被持久化。#appendfsync no AOF重写 AOF日志文件会随着redis运行越来越庞大，Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身；也可以使用配置文件进行自动瘦身； 1234# 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。auto-aof-rewrite-percentage 100 # 当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb 要禁用自动的日志重写功能，我们可以把百分比设置为0 1auto-aof-rewrite-percentage 0 优点 使用fsync每秒一次同步，数据完整性较高； redis如果发生宕机，支持使用redis-check-aof 工具修复损坏的AOF文件 缺点 AOF文件的大小一般会比RDB文件大 AOF在运行效率上往往会慢于RDB 关注公众号：知识追寻者，获取一线大厂面经","path":"2020/11/13/redis/redis持久化（九）/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis布隆过滤器（八）","text":"一布隆过滤器简介布隆过滤器（Bloom Filter）是 1970 年由布隆提出的类似于Set的数据结构。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中，但检索的结果并不是很精确，数据量变大的就会产生误判情形，但布隆过滤器的都是能过滤掉已经存在的内容，所以误判的情况就是不在布隆过滤器中的数据有可能误判为已经存在，这个功能在某些场景下很有用。 布隆过滤器使用场景 布隆过滤器最大的作用就是大数据量下的去重功能，所以经常使用在如下场景 推荐系统，比如商品，新闻推荐，去除已经推荐过的新闻或商品； 网页爬虫对 URL 去重，避免爬取相同的 URL 地址； 大数据情况下，从邮件中判定垃圾邮箱； 二布隆过滤器原理简介布隆过滤器是由一串很长的二进制向量组成，可以将其看成一个二进制数组；存放0或者1，默认都是0； 添加数据 向布隆过滤器中添加一个元素key时，通过多个hash函数计算多个hash值，并将对应位置的值置为1；由于不同的key就有不同1的位置，用于区分key；但是但数据量大的时候，就会出现相同key被几个hash函数hash后的值一样，所以会出现误差； 布隆过滤器使用contain方法判断元素是否在过滤器中达到去重效果； 三实现方式3.1guava库实现添加guava依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt; &lt;version&gt;29.0-jre&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 实现： 12345678910111213141516171819202122@Testpublic void contextLoads() &#123; // 总数量1W int total = 10000; // 设置过滤器 BloomFilter&lt;CharSequence&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total); // 初始化 1W条数据到过滤器中 for (int i = 0; i &lt; total; i++) &#123; bf.put(&quot;知识追寻者&quot; + i); &#125; // 判断值是否存在过滤器中 int count = 0; // 插入2w 条数据进行去重校验 int addCount = 2*total; for (int i = 0; i &lt; addCount; i++) &#123; if (bf.mightContain(&quot;知识追寻者&quot; + i)) &#123; count++; &#125; &#125; System.out.println(&quot;匹配数量 &quot; + count);&#125; 控制台输出匹配数量大于1w，所以能起到过滤重复数据的作用； 1匹配数量 10294 调节fpp误判率可以实现比较精确的过滤 1294&#x2F;2w&#x3D;0.0147 fpp默认是0.03d, 设置为0.0147d 12BloomFilter&lt;CharSequence&gt; bf &#x3D; BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), total,0.0147d); 匹配结果如下 1匹配数量 10143 3.2redis实现方式redis 4.0 版本才支持布隆过滤器 redis实现方式使用指令 bf.add 添加元素，bf.exists 查询元素是否存在；数据量小的时候看不出来具体差别 1234567891011121314127.0.0.1:6379&gt; bf.add codeding h1(integer) 1127.0.0.1:6379&gt; bf.add codeding h2(integer) 1127.0.0.1:6379&gt; bf.add codeding h3(integer) 1127.0.0.1:6379&gt; bf.exists codeding h1(integer) 1127.0.0.1:6379&gt; bf.exists codeding h2(integer) 1127.0.0.1:6379&gt; bf.exists codeding h3(integer) 1127.0.0.1:6379&gt; bf.exists codeding h4(integer) 0 使用Redisson实现，版本 3.x以上 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.11.4&lt;/version&gt;&lt;/dependency&gt; 如果是springboot 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt; 实现代码 12345678910111213141516171819202122232425262728@Test public void test2()&#123; Config config = new Config(); config.useSingleServer().setAddress(&quot;redis://ip:port&quot;); config.useSingleServer().setPassword(&quot;密码&quot;); //构造Redisson RedissonClient redisson = Redisson.create(config); // 获取布隆过滤器 RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(&quot;userList&quot;); //初始化布隆过滤器：预计元素为1wL,误差率为3% // 总数量100 long total = 100L; bloomFilter.tryInit(total,0.03); // 初始化 1W条数据到过滤器中 for (int i = 0; i &lt; total; i++) &#123; bloomFilter.add(&quot;zszxz&quot; + i); &#125; int count = 0; // 200 条数据进行去重校验 long addCount = 2*total; for (int i = 0; i &lt; addCount; i++) &#123; if (bloomFilter.contains(&quot;zszxz&quot; + i)) &#123; count++; &#125; &#125; // 匹配数量 108 System.out.println(&quot;匹配数量 &quot; + count); &#125; 匹配数量为 108 ，比100多了8条；也可以通过调整误差率实现较为精确的过滤； 关注知识追寻者，获取2020版面试题一份","path":"2020/11/13/redis/redis布隆过滤器（八）/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis应用HyperLogLog（七）","text":"一 HyperLogLog 介绍 Redis 在 2.8.9 版本添加了 HyperLogLog 结构。 在 Redis 中，HyperLogLog 是它的一种高级数据结构， 其功能结构类似于Set； HyperLogLog 经常使用于系统数据的不精确去重，标准误差为0.81%； 每个 HyperLogLog 键只需要12 KB 内存，就可以统计 2^64 个不同的元素； HyperLogLog 提供了两个指令用于计数统计，pfadd 为 添加数据；pfcount 为统计数据个数； pfadd 指令来源于 Philippe Flajolet 发明了 HyperLogLog 这种数据结构，所以pf就是指其姓名的缩写；我们之前说过 HyperLogLog 这种数据结构能起到不精确确的去重效果，但必须是亿级流量的数据以上，否则就是浪费空间，因为每个键需要占据12kb的存储空间； 使用示例如下 1234567891011127.0.0.1:6379&gt; pfadd abin zk1(integer) 1127.0.0.1:6379&gt; pfadd abin zk2(integer) 1127.0.0.1:6379&gt; pfcount abin(integer) 2127.0.0.1:6379&gt; pfadd abin zk3(integer) 1127.0.0.1:6379&gt; pfcount abin(integer) 3127.0.0.1:6379&gt; HyperLogLog 还提供了 pfmerge 指令用于合并key，的到的结果是去重后的并集； 二 使用场景 统计注册 IP 数 统计每日访问 IP 数 统计页面实时 UV 数 统计在线用户数 统计用户每天搜索不同词条的个数 三 java实现java实现非常简单，使用jedis方式实现代码如下；使用 pfadd指令 添加 1w条数据，最终计算的结构是 10055 条； 多了 55条， 可见统计是存在一些误差，但在大数据情况下一些误差是完全更够接收； 123456789101112@Test public void testHyperLogLog()&#123; // 插入1W条数据 Jedis jedis = jedisUtil.getJedis(); for (int i=0; i &lt; 10000; i++)&#123; jedis.pfadd(&quot;abin&quot;,&quot;zk&quot;+i); &#125; long abinCount = jedis.pfcount(&quot;abin&quot;); //10055 System.out.println(abinCount); jedis.close(); &#125; 四 HyperLogLog 原理HyperLogLog 原理实现非常复杂，但使用方式非常简单；我对这类算法的兴趣也不是很高，有兴趣的可以参考如下文章进行学习 https://juejin.im/post/6844903785744056333 https://zhuanlan.zhihu.com/p/58519480 五 思考HyperLogLog 与 布隆过滤器都起到了去重效果，它们之间有什么区别？","path":"2020/11/13/redis/redis应用HyperLogLog（七）/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis跳跃表与二分查找（六）","text":"一 前言本篇内容主要是讲解redis跳跃表的基础概念，科普一下读者知道有这种随机数据结构的概念,。 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 跳跃表2.1 分查找的思想说起跳跃表，我们先来回忆一下 二分查找， 这将有助于我们更加容易理解 跳跃表； 一串有序数组如下 , 我们现在想要 以较快的速度查找出该数组的中的125; 1 , 2 , 6, 25 , 32 , 48 , 56 ,73 , 85 , 96, 125 ,135 , 148 首先 125 比中位数56大，向右查找; 剩余如下 …….,73 , 85 , 96, 125 ,135,148 其次 125 比 96 大，向右查找； ………..125 ,135,1148 125 比 135 小， 往左 查找；最终结果125； 故经过4次查找后就找到了本次有序数组中的值； 其时间复杂度未O(logN) ; 如果一个正常的数组进行查找，需要逐个比较，其时间复杂度为 O(N); 明显 二分查找比普通的数组查找快很多； 其java代码实现如下 123456789101112131415161718192021222324252627282930313233/** * @Author lsc * &lt;p&gt; &lt;/p&gt; */public class BinaryaFind &#123; public static void main(String[] args) &#123; BinaryaFind binaryaFind = new BinaryaFind(); int[] array = &#123;1 , 2 , 6, 25 , 32 , 48 , 56 ,73 , 85 , 96, 125 ,135 , 148&#125;; int result = binaryaFind.binarySearch(array, 125, 0, array.length - 1); // result = 10; array[result] = 125 System.out.println(array[result]); &#125; /* * * @Author lsc * &lt;p&gt;递归实现二分查找 &lt;/p&gt; * @Param [array, target, start, end] */ private int binarySearch(int[] array, int target, int start, int end) &#123; if (start &gt; end) &#123; return -1; &#125; int mid = start + (end - start) / 2; if (array[mid] == target) &#123; return mid; &#125; else if (target &lt; array[mid]) &#123; return binarySearch(array, target, start, mid - 1); &#125; else &#123; return binarySearch(array, target, mid + 1, end); &#125; &#125;&#125; 2.2 跳跃表的概念跳跃表（skiplist)是一种随机化的数据结构，William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出， 跳跃表以有序的方式在层次化的链表中保存元素； 在redis 中的主要应该为zset有序集合的底层实现； zskiplist结构的定义如下， 其是跳跃表 12345678910typedef struct zskiplist &#123; // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level;&#125; zskiplist; redis.h/zskiplistNode 结构定义如下,其是跳跃表节点 1234567891011121314151617typedef struct zskiplistNode &#123; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; &#125; level[];&#125; zskiplistNode; 先不管这段代码你是否读懂，现在我们列出比较重要的概念 header：指向跳跃表的表头节点，维护跳跃表节点指针，最高层级为32层 tail：指向跳跃表的表尾节点，尾节点全部由null组成 level：记录目前跳跃表最大层级；查找时总是由高层往低层级进行查找； length：记录跳跃表的长度 zskiplistNode： 节点，保存跳跃表数据信息，前进和后退指针； 其次再看下下图 如果进行查找 member = z , score = 5 , 那么 其查找过程为 从表头 到member = x 的L5 层, spand(跨度) = 1；然后 从 member = x 的 L3 层 到 merber =y 的L3 层； 最后从 merber =y 的L3 层 到 merber =z 的L2层； 跨度代表了2个层级之间的距离，跨度越大，距离越远； 当数据量很大时，通过跳跃表，可以直接通过层级跳跃的方式， 进行查找，有可能 member = x 的 leve l=5, member = y 的 level =3 ; merber =z 的 level =5 , 此时直接进行查找就只需要通过一次L5 到L5找就可以找到 member = z 的 score； 固总体来说 其查找的时间复杂度为O(logN); heard , 和 tail 直接可以通过表头，表尾定位得到，其时间复杂度为 O(1)； 关于插入和删除，也是建立在查找的基础上，固其事件复杂度平均也为平均 O(logN)； 2.3 跳跃表API时间复杂度 zslCreateNode 创建并返回一个新的跳跃表节点 最坏 O(1) zslFreeNode 释放给定的跳跃表节点 最坏 O(1) zslCreate 创建并初始化一个新的跳跃表 最坏 O(1) zslFree 释放给定的跳跃表 最坏 O(N) zslInsert 将一个包含给定 score 和 member 的新节点添加到跳跃表中 最坏 O(N) 平均 O(logN) zslDeleteNode 删除给定的跳跃表节点 最坏 O(N) zslDelete 删除匹配给定 member 和 score 的元素 最坏 O(N) 平均 O(logN) zslFirstInRange 找到跳跃表中第一个符合给定范围的元素 最坏 O(N) 平均 O(logN) zslLastInRange 找到跳跃表中最后一个符合给定范围的元素 最坏 O(N) 平均 O(logN) zslDeleteRangeByScore 删除 score 值在给定范围内的所有节点 最坏 O(N2) zslDeleteRangeByRank 删除给定排序范围内的所有节点 最坏 O(N2) zslGetRank 返回目标元素在有序集中的排位 最坏 O(N) 平均 O(logN) zslGetElementByRank 根据给定排位，返回该排位上的元素节点 最坏 O(N) 平均 O(logN) 2.4 选择跳跃表的理由总体来说，其实现方式没有红黑数那么复杂，算法速度较快，平均时间复杂度为O(logN)； 三 参考文档https://blog.csdn.net/universe_ant/article/details/51134020 https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html 《redis设计与实现》","path":"2020/11/13/redis/redis跳跃表与二分查找（六）/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis发布订阅模式(五)","text":"一 前言虽然有消息队列，我们还是要了解一下redis发布订阅模式哟！！！！！ 二发布订阅模式 PUBLISH 命令向通道发送信息，此客户端称为publisher 发布者； SUBSCRIBE 向命令通道订阅信息，此客户端称为subscriber 订阅者； redis 中 发布订阅模块的名字叫着 PubSub，也就是 PublisherSubscriber； 一个发布者向一个通道发送消息，订阅者可以向多个通道订阅消息；当发布者向通道发布消息后，如果有订阅者订阅该通道，订阅者就会收到消息；这有点像电台，我收听了一个电台的频道，当频道发送消息后，我就能收到消息； 三PUBSub模块命令 subscribe： 订阅一个或者多个频道； unsubscribe: 退订一个或者多个频道； publish: 向通道发送消息； psubscribe: 订阅给定模式相匹配的所有频道； punsubscribe: 退订 给定模式所有的频道，若未指定模式，退订所有频道； 具体的命令使用方式 可以使用 help 命令 ;示例如下： 1help subscribe 四客户端实现通过指令SUBSCRIBE订阅一个频道，如果频道不存在时则新建一个频道；此时此客户端就是订阅者 123456127.0.0.1:6379&gt; subscribe zszxzReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;zszxz&quot;3) (integer) 1 通过指令publish向通道发送一个消息；此时客户端就是发布者 123127.0.0.1:6379&gt; publish zszxz &quot;l miss you&quot;(integer) 1127.0.0.1:6379&gt; 我们再看看 客户端就收到消息了 12345678127.0.0.1:6379&gt; subscribe zszxzReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;zszxz&quot;3) (integer) 11) &quot;message&quot;2) &quot;zszxz&quot;3) &quot;l miss you&quot; 五java 实现定义2个订阅者用于订阅频道的消息，在使用jedis 时 需要 继承 JedisPubSub 类， 并重写 onMessage 方法； 订阅者可以在该方法里面进行消息的业务逻辑处理； 订阅者 1 123456789101112/** * @Author lsc * &lt;p&gt;订阅者1号 &lt;/p&gt; */@Componentpublic class Sub1 extends JedisPubSub &#123; @Override public void onMessage(String channel, String message) &#123; System.out.println(&quot;sub1 channel is :&quot;+ channel+ &quot; mesage is :&quot;+message); &#125;&#125; 订阅者2 123456789101112/** * @Author lsc * &lt;p&gt;订阅者2号 &lt;/p&gt; */@Componentpublic class Sub2 extends JedisPubSub &#123; @Override public void onMessage(String channel, String message) &#123; System.out.println(&quot;sub2 channel is :&quot;+ channel+ &quot; mesage is :&quot;+message); &#125;&#125; 发布者 1234567891011/** * @Author lsc * &lt;p&gt; &lt;/p&gt; */@Componentpublic class Pub &#123; public void publishMessage(Jedis jedis, String channel, String msg) &#123; jedis.publish(channel,msg); &#125;&#125; 测试类、 注意redis 的 发布订阅模式 是阻塞模式 ，一个订阅者需要 重新起一个线程； 12345678910111213141516171819202122232425262728@AutowiredPub pub;@AutowiredJedisUtil jedisUtil;@AutowiredSub1 sub1;@AutowiredSub1 sub2;@Testpublic void test()&#123; new Thread(()-&gt; &#123; while (true)&#123; jedisUtil.getJedis().subscribe(sub1,&quot;zszxz&quot;); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //jedisUtil.getJedis().subscribe(sub2,&quot;zszxz&quot;); &#125;).start(); pub.publishMessage(jedisUtil.getJedis(),&quot;zszxz&quot;,&quot;l miss you&quot;);&#125; 六 缺点 PubSub 的生产者来一个消息会直接传递给消费者。如果没有消费者，消息会直接丢弃。如果有多个消费者，一个消费者突然挂掉，生产者会继续发送消息，另外的消费者可以持续收到消息。但是挂掉的消费者重新连上后，断连期间的消息会彻底丢失； 如果 Redis 停机重启，PubSub 的消息是不会持久化 求关注","path":"2020/11/13/redis/redis发布订阅模式-五/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis事物（四）","text":"事物介绍有时候我们需要redis连续发送多个命令不能被中断，此时就需要使用到redis特殊的命令功能；redis有 5个命令可以实现多个命令执行操作，他们分别是WATCH, MULTI（开启事物）, EXEC（执行命令）, UNWATCH 和 DISCARD（丢弃事物）; Redis事物需要使用到MULTI和 EXEC命令，其和关系型数据库的回滚事物不同；redis会一个接着一个执行保含在MULTI和 EXEC 命令范围内的命令；只有执行完redis事物的命令才会执行其它客户端命令；我们已经可以理解首先执行的是MULTI命令，其次是我们想要在事物里面执行的命令，最后是EXEC命令执行完队列中的命令代表结束。Redis在执行事物的时候，其实会开启队列，将我们要执行的事物命令放入队列中，所以命令必须一个执行完毕才能执行下一个命令； 事物示例首先执行multi 命令 123127.0.0.1:6379&gt; multi # 开启事物OK127.0.0.1:6379&gt; 其次输入我们的命令，放入队列中 1234567127.0.0.1:6379&gt; set z1 666QUEUED127.0.0.1:6379&gt; set z2 555QUEUED127.0.0.1:6379&gt; set z3 222QUEUED127.0.0.1:6379&gt; 最后EXEC命令执行队列中的命令 12345127.0.0.1:6379&gt; exec # 执行命令1) OK2) OK3) OK127.0.0.1:6379&gt; 事物原子性事物的原子性是指事物要么全部成功，要么全部失败；即出现异常的时候会事物会回滚；但redis的事物并不是原子性，如下示例中可以看出出现异常后，事物照样运行命令； 12345678910111213141516127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 000QUEUED127.0.0.1:6379&gt; set k2 66 66 66QUEUED127.0.0.1:6379&gt; set k3 000QUEUED127.0.0.1:6379&gt; exec1) OK2) (error) ERR syntax error3) OK127.0.0.1:6379&gt; keys k*1) &quot;k3&quot;2) &quot;k1&quot;127.0.0.1:6379&gt; discard丢弃丢弃是指丢弃队列中所有的命令，这样multi命令就相当于未发生过；discard 命令 需在exec命令之前执行； 1234567891011127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set s1 111QUEUED127.0.0.1:6379&gt; set s2 222QUEUED127.0.0.1:6379&gt; discard # 丢弃OK127.0.0.1:6379&gt; exec(error) ERR EXEC without MULTI127.0.0.1:6379&gt; watch监控我们都知道 redis 的 分布式锁是一个悲观锁，提供了很好的并发解决方案；但更好的方式是使用watch命令来监控一个值是否变化，如果值发生改变，exec执行的命令将会返回null，故watch 命令是一个乐观锁的解决方案； 12345678910111213127.0.0.1:6379&gt; set s3 oooOK127.0.0.1:6379&gt; watch s3OK127.0.0.1:6379&gt; set s3 555 # 修改了变量OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set s3 222QUEUED127.0.0.1:6379&gt; exec(nil)127.0.0.1:6379&gt; Redis 不可以在 multi 和 exec 之间执行 watch 指令，必须在 multi 之前执行，否则报错； unwacth 命令是撤销对一个变量的监控；","path":"2020/11/13/redis/redis事物（四）/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis实现分布式锁(三)","text":"一 前言redis在分布式应用十分广泛，本篇文章也是互联网面试的重点内容，读者至少需要知道为什么需要分布式锁，分布式锁的实现原理，分布式锁的应用场景，在使用分布式锁时遇到哪些问题?你是如何解决的，如果读者能掌握以上问题，那么关于这道面试题，你也就基本过关了； 二 分布式锁的产生背景分布式锁对应的是多个应用，每个应用中都可能会处理相同的数据，如果多个应用对用一个操作进行了重复操作，就会出现数据不一致，数据重复问题，于是分布式锁应用而生，通常你可以理解为多线程中的synchronized 三 分布式锁的应用场景 多台机器都能执行某个任务，如果限制任务每次只能被一台机器执行，不能重复执行，就可以用分布式锁来做标记 秒杀场景，要求并发量很高，那么同一件商品只能被一个用户抢到，就可以使用分布式锁实现 比较敏感的数据比如金额修改，同一时间只能有一个人操作，如果2个人同时修改金额，一个加一个减金额，为了防止同时操作造成数据不一致，就可以使用分布式锁实现 四 分布式锁的实现4.1 分布式锁的实现方式 基于数据库实现分布式锁 基于缓存（redis，memcached，tair）实现分布式锁 基于Zookeeper实现分布式锁 4.2 分布式锁使用原理每个应用对敏感数据进行操作时都需要向获取一个锁，持有锁的应用才能对数据进行操作，保证在同一时间内只有一台应用能对数据进行操作； 4.3 分布式锁实现过程基本实现思路： redis分布式实现是基于 命令setnx key value ， 其意指 若该键不存在则创建键，这就保证了redis中只有一个该键，故应用谁先获得该键，谁就拿到了锁的权限；然后业务逻辑执行完毕则需要使用 del key 删除键，表示释放锁； 出现了问题： 如果一台业务逻辑执行完毕，程序出现异常，则锁会一直存在，没有得到释放，其它应用就会无法获得锁，此时就会造成死锁问题； 改进方式： 拿到锁之后，给锁加上一个过期时间，也就是 expire key seconds 指令；此时避免了死锁问题，但是由于业务逻辑执行的时间不同，过期的时间设置也是一个问题，故通常分布式锁不能应用于业务逻辑执行较长的程序； 出现问题： 由于redis 每条指令都是原子性操作，但由于setnx 和 expire 是2 条指令，如果在执行setnx后程序出现问题expire指令未得到执行就会造成死锁问题； 解决问题： redis2.8版本之后引入了指令 set key value [EX seconds] [PX milliseconds] [NX|XX] ,该指令可以同时执行 setnx 和 expire ，于是解决了死锁问题； 参数列表解释 EX seconds: 设定过期时间，单位为秒 PX milliseconds: 设定过期时间，单位为毫秒 NX: key不存在时设置值 XX: key存在时设置值 使用jedis客户端实现分布式锁方式 12345public boolean lock(Jedis jedis,String key,String val,int expireTime)&#123; String lock &#x3D; jedis.set(key, val, &quot;NX&quot;, &quot;PX&quot;, expireTime); return &quot;OK&quot;.equals(lock);&#125; 关于未获得锁的解决思路： 可以直接抛出异常让客户重试 可以使用延迟队列 五 分布式锁的超时问题问题： 如果在加锁和释放锁之间，业务逻辑执行时间太长，导致超出了锁的超时限制，就会出现锁过期问题；换句话说，就是第一台应用执行了业务，导致锁过期；第二台应用此时可以获得锁，进行执行业务，此时第一台应用释放了锁，第二台应用在执行业务的时第三台应用获得了锁执行业务，导致在执行过程中，会有2台应用在同时执行业务逻辑； 解决思路： 在释放锁的时候出现了问题，即每台应用都可以释放锁，这会造成1应用的锁释放了2应用锁的问题，换句话说，很多人手中持有的钥匙是通用的，都可以开同一个门；为了避免这个问题，就是1 应用只能释放1应用上的锁，2应用只能释放2应用上的锁，则需要对释放锁进行身份校验；由于上锁的时候key是唯一，但value可以不同，所以可以根据value进行身份的唯一标识，随机数就是一个很好的选择 ： 1String value &#x3D; UUID.randomUUID().toString(); 由于考虑到匹配到value校验和del不是同一个操作，故需要使用Lua脚本实现多条指令的原子性执行； jedis释放锁实现方式： 1234567public void unlock(Jedis jedis,String key,String value) &#123; String script_command &#x3D; &quot;if redis.call(&#39;get&#39;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then &quot; + &quot;return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot;; &#x2F;&#x2F; 解锁 jedis.eval(script_command, Collections.singletonList(key), Collections.singletonList(value)); &#125; 六 传送门如果再有人问你什么是分布式锁，把这几篇文章砸像他 https://juejin.im/post/5cc165816fb9a03202221dd5 https://www.jianshu.com/p/268e5d4ce045","path":"2020/11/13/redis/redis实现分布式锁三/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis我与SDS的初见(二)","text":"一 前言本篇文章是初步认识redis的字符串数据结构SDS（Simple Dynamic String）， 其意指简单的动态字符串，字面上的含义就是smiple 代指简单，操作简单，使用者能够快点理解上手，无需关心redis内部实现；Dynamic 指动态扩展，表是能够自动的对内存空间进行动态分配；String 表示字符串，不难理解； 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 SDS结构2.1 redis SDS数据结构redis3.2之前数据结构如下； 12345struct sdshdr &#123; unsigned int len; unsigned int free; char buf[]; &#125;; len 表示 buf（缓冲区）中已经使用的空间长度； free 表示 buf中未使用的长度； buf[] 表示缓冲区数组，存储字符； 2.12 redis 缓冲区结构更加的形象的一个存储图像如下 buf 中的实际大小为 11（len + free + 1），其中已经使用空间 len = 5 , 未使用空间 free=5; 保留位空字符 \\0 占一位；当我们在redis储存进一个字符串zxzxz 的时候 就已经给我们分配好了内存空间，以及后面能用使用的内存空间；如果是c 语言那么要得到一个 zxzxz 字符长度就需要遍历整个字符数组 遇到 \\0 （C语言以\\0区分内存空间中的字符串）后结束，才计算出一个字符串的长度，然而redis只需要一个sdslen(非c语言读者不必纠结此类API) 就可以计算得出字符串长度； 从算法角度来看 redis 的一次获取字符串长度 为 O(1), c 语言 为 O(N), 所以redis 快很多; 2.2 redis 空间分配策略其次通过上图可以发现 储存一个字符串 zxzxz ， 其所占长度为5 ， 为使用空间为5，\\0 占1 ；原因是 redis字符串 储存大小小于1MB 的时候 ， 存储任意的字符串， 其 free大小永远与 自身的大小相同；当字符串 大小大于1MB时，其就分配free大小固定为1MB， 此称为空间预分配策略； 如果是c语言 则需要 计算当前字符串在buf中的长度，再计算即将追加的字符串长度，然后分配空间大小；故redis 的速度是相当快，相比于c 操作内存空间； c 语言 在操作内存空间的时候要不断的计算大小，在追加字符串的时候分配空间大小，如果未进行分配，那么追加的字符串有可能覆盖已经 已经储存到 内存空间的字符串； 比如 内存空间 储存 zzz \\0kkk\\0; 储存 zzz 的时候所占用3 个位，加一个未分配空间1位，如果向zzz字符串进行追加一个ggg， 那么在未进行计算分配空间的情况下 原有的数据会变成 zzzggg\\0k\\0, 很直观的发现 内存溢出， 第一个字符串就覆盖至第二个字符串的部分内容； 所以 redis 的操作内容空间是杜绝内存溢出，并且能够储存图片，视频等二进制数据，如果是c语言操作储存，二进制文件中一个\\0就可能导致内存泄漏，缓冲区溢出等，故c语言一般只操作文本文件； 三 相关链接如果想要深入redis之SDS源码，可以参考如下链接； https://blog.csdn.net/yangbodong22011/article/details/78419966 https://juejin.im/post/5cdbafedf265da037c7d090f https://blog.csdn.net/qq193423571/article/details/81637075 https://lynnapan.github.io/2017/07/14/redis_sds/","path":"2020/11/13/redis/redis我与SDS的初见-二/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"redis入门基础(一)","text":"一 前言知识追寻者的redis开篇第一篇，希望大家共勉；觉得文章不错，随手点赞关注谢谢； 先介绍一下redis概念： Redis是一个开源的key-value存储系统，它属于NoSQL(Not Only SQL)，不仅仅是关系型数据库； 再看看redis的优势： 丰富的数据类型 支持键过期特性 每条指令都是原子性操作 读写性能极高 初步了解一下redis的附加特性 可以主存与二级存储，主从复制； 支持数据持久化存储 linux 安装 redis 链接 ： https://www.jianshu.com/p/bc84b2b71c1c windows安装redis链接： https://www.jianshu.com/p/e16d23e358c0 docker 安装 redis 链接 https://juejin.im/post/5ca59dece51d4508b32a1292 最后生产环境中建议大家安装 redis 5.0.5 稳定版本 二 五大基础数据类型2.1 字符串字符串型数据存储为 key - val （键值对）形式，即每个 键都有对应唯一的值；如下图所示，age 为 key 则对应唯一的值为18； 命令介绍如下 get : 获取存储给定键的值 set : 设置给定存储键的值 del : 删除给定键的值 incr ：计数，每次加1 incrby : 计算，给定值加减 mset : 设置多个键值 mget : 获取多个给定键的值 expire : 设置过期时间（适用所有类型） exists ： 是否存在键 存储字符串示例 set key value 12127.0.0.1:6379&gt; set zszxz 666OK 获取字符串示例 get key 12127.0.0.1:6379&gt; get zszxz&quot;666&quot; 删除字符串示例 del key [key ...] 12127.0.0.1:6379&gt; del zszxz(integer) 1 计数示例： incr key 123456789127.0.0.1:6379&gt; set age 100OK127.0.0.1:6379&gt; incr age(integer) 101127.0.0.1:6379&gt; incr age(integer) 102127.0.0.1:6379&gt; get age&quot;102&quot;127.0.0.1:6379&gt; incrby key increment 123456789127.0.0.1:6379&gt; set age 100OK127.0.0.1:6379&gt; incrby age 5(integer) 105127.0.0.1:6379&gt; incrby age -2(integer) 103127.0.0.1:6379&gt; get age&quot;103&quot;127.0.0.1:6379&gt; 多键值对示例 mset key value [key value …] mget key [key …] 123456127.0.0.1:6379&gt; mset u1 you1 u2 you2OK127.0.0.1:6379&gt; mget u1 u21) &quot;you1&quot;2) &quot;you2&quot;127.0.0.1:6379&gt; 设置过期时间 expire key seconds 12345127.0.0.1:6379&gt; expire u1 1(integer) 1127.0.0.1:6379&gt; get u1(nil)127.0.0.1:6379&gt; 存在示例 exists key [key …] 12345127.0.0.1:6379&gt; set age 100OK127.0.0.1:6379&gt; exists age(integer) 1127.0.0.1:6379&gt; 2.2 列表列表其实就是链表，一个列表有一个键，一个键对应多个值，值可以重复，取值时根据索引取值即可； rpush : 将值推入列表右端 lrange : 获取列表给定范围内所有的值 lindex : 获取列表上给定位置的单个元素 lpop : 从列表的左端弹出一个值 值入列表示例 rpush key value [value ...] 123456127.0.0.1:6379&gt; rpush list-zszxz a(integer) 1127.0.0.1:6379&gt; rpush list-zszxz b(integer) 2127.0.0.1:6379&gt; rpush list-zszxz c(integer) 3 范围取值示例 lrange key start stop 1234127.0.0.1:6379&gt; lrange list-zszxz 0 -11) &quot;a&quot;2) &quot;b&quot;3) &quot;c&quot; 给定索引取值示例 lindex key index 12127.0.0.1:6379&gt; lindex list-zszxz 1&quot;b&quot; 左弹出示例 lpop key 12345127.0.0.1:6379&gt; lpop list-zszxz&quot;a&quot;127.0.0.1:6379&gt; lrange list-zszxz 0 -11) &quot;b&quot;2) &quot;c&quot; 2.3 集合集合与列表类似，不过特殊指出是集合无序，并且每个值都是唯一，不可重复； sadd : 将给定的值加入集合 smembers : 返回集合所有的元素 sismember : 检查给定的元素是否存在集合中 srem : 若集合中存在该元素，则移除该元素 添加示例 sadd key member [member ...] 123456127.0.0.1:6379&gt; sadd set-zszxz a(integer) 1127.0.0.1:6379&gt; sadd set-zszxz b(integer) 1127.0.0.1:6379&gt; sadd set-zszxz c(integer) 1 返回所有元素示例 smembers key 1234127.0.0.1:6379&gt; smembers set-zszxz1) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot; 存在示例 sismember key member 12127.0.0.1:6379&gt; sismember set-zszxz c(integer) 1 删除示例 srem key member [member ...] 12345127.0.0.1:6379&gt; srem set-zszxz a(integer) 1127.0.0.1:6379&gt; smembers set-zszxz1) &quot;c&quot;2) &quot;b&quot; 2.4 散列散列点像java中的map，python中的字典；一个散列里面存储多个键值对； hset : 给定散列的键值对 hget : 获取指定散列键的值 hetall : 获取所有散列的键值对 hdel : 若散列中存在该键，则移除键 设置散列键值对示例 hset key field value 1234567127.0.0.1:6379&gt; hset hash-key key1 a(integer) 1127.0.0.1:6379&gt; hset hash-key key2 b(integer) 1127.0.0.1:6379&gt; hset hash-key key3 c(integer) 1127.0.0.1:6379&gt; 获取散列给定键示例 hget key field 12127.0.0.1:6379&gt; hget hash-key key1&quot;c&quot; 获取散列所有键值对示例 hgetall key 1234567127.0.0.1:6379&gt; hgetall hash-key1) &quot;key1&quot;2) &quot;c&quot;3) &quot;key2&quot;4) &quot;b&quot;5) &quot;key3&quot;6) &quot;c&quot; 删除散列键示例 hdel key field [field ...] 12345678127.0.0.1:6379&gt; hdel hash-key key1(integer) 1127.0.0.1:6379&gt; hgetall hash-key1) &quot;key2&quot;2) &quot;b&quot;3) &quot;key3&quot;4) &quot;c&quot;127.0.0.1:6379&gt; 2.5 有序集合redis 有序集合与散列类似，不同之处键称为member, value称为 score ; 根据分值不同进行有序排序； zadd ： 将带有给定分值的成员添加入有序集合 zrange : 根据有序集合的索引获取元素 zrangebyscore : 获取有序集合内给定分值范围内的所有元素 zrem : 如果成员存在有序集合中，则移除 添加成员示例 zadd key score member [score member ...] 1234567127.0.0.1:6379&gt; zadd zset-key 600 member1(integer) 1127.0.0.1:6379&gt; zadd zset-key 650 member2(integer) 1127.0.0.1:6379&gt; zadd zset-key 680 member3(integer) 1127.0.0.1:6379&gt; 获取指定索引范围内的成员示例 zrange key start stop [WITHSCORES] 不带score 1234127.0.0.1:6379&gt; zrange zset-key 0 -11) &quot;member1&quot;2) &quot;member2&quot;3) &quot;member3&quot; 带上score 1234567127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) &quot;member1&quot;2) &quot;600&quot;3) &quot;member2&quot;4) &quot;650&quot;5) &quot;member3&quot;6) &quot;680&quot; 获取指定分值范围内的成员示例 zrangebyscore key min max [WITHSCORES] [LIMIT offset count] 12345127.0.0.1:6379&gt; zrangebyscore zset-key 600 650 withscores1) &quot;member1&quot;2) &quot;600&quot;3) &quot;member2&quot;4) &quot;650&quot; 移除成员示例 zrem key member [member ...] 12345678127.0.0.1:6379&gt; zrem zset-key member1(integer) 1127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores1) &quot;member2&quot;2) &quot;650&quot;3) &quot;member3&quot;4) &quot;680&quot;127.0.0.1:6379&gt; 简记方式： 字符串， key - value 列表与集合 ，类似链表，一个有序，一个无序，一个键存储多个值； 散列与有序集合，类似字典，map；储存多个 key-value; 有序集合的key 为member, value 为 score ,按照分值排序；","path":"2020/11/13/redis/redis入门基础-一/","date":"11-13","excerpt":"","tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"}]},{"title":"基于Hexo搭建个人博客","text":"一 前言不知道你们有没有这种感觉，使用一些网上博客写文章会嫌弃广告太多，很影响阅读体验，于是有了个人博客的诞生；知识追寻者抽空 写了篇使用GitHub Pages 服务搭建个人博客，当然个人博客也有许多缺点，毕竟不是自己的开发，只能套用别人主题模板，难免功能上有些缺陷，人生不如意之事，十有八九，搭建个人博客也是如此； 知识追寻者搭建的个人博客如下，体验地址如下: https://zszxz.github.io/ 有这方面兴趣的读者可以参考本篇文章进行搭建 二准备工作 需要一个 GitHub 账号； 需要安装 node.js、npm，并了解相关基础知识； 需要安装git for windows（或者其它 git 客户端）； github 注册地址： https://github.com/ Node官网: https://nodejs.org/en/download/ (10版本以上) 安装完在cmd窗口执行 如下命令 显示版本号说明安装成功； 1node -v git官网: https://git-scm.com/ 填写用户名 邮箱 12$ git config --global user.name &quot;user_name&quot; # user_name填入GitHub用户名$ git config --global user.email &quot;user_email&quot; # user_email填入GitHub注册的邮箱 查看已经配置的用户名邮箱 12$ git config user.name$ git config user.email github 配置 ssh key 自行搜索配置，否则后文仓库无法发布 三安装 hexoHexo 是一个简单、快速、强大的基于 Github Pages 的博客框架，支持 Markdown 格式，有众多优秀插件和主题，详细 参考官网： https://github.com/hexojs/hexo 创建 myBlog 目录，比如知识追寻者的创建目录如下 1C:\\mydata\\book\\myBlog 在myBlog目录中 打开 git Bash 执行如下命令，安装 hexo 1npm install hexo-cli -g 接着 执行如下命令，实际上是从 github拉去 hexo代码 1hexo init 拉去完后目录内容如下 themes 目录存放博客的主题信息； source目录存放文章 _config.yml 存放hexo的配置文件 接下来 执行 如下一组命令。安装 npm依赖和编译静态文件 12npm installhexo g 执行完成后 文件夹中多出 public 目录 用于存放静态文件 接着执行本地预览命令 1hexo s 浏览器打开 http://localhost:4000/ 出现如下界面表示本地搭建成功； 四基本配置由于 默认hexo 的静态页面比较丑，所以我们需自定义主题； 在source/_post 目录下有个hello-word.md文件，替换为我们自己的hello-word.md文章 然后 使用 如下命令创建博客文章 1hexo new &quot;文件名&quot; 你就可以在里面随意书写内容 之后执行如下一组命令进行缓存清除，重新生成本地预览，运行 123hexo cleanhexo ghexo s 重新运行后的网站首页如下 打开 _config.yml 文件 修改 标题和 作者重新启动 打开网址发现界面是真的丑 打开 官方主题 网址 https://hexo.io/themes/ 挑选自己喜欢的主题，点击进入主题 github地址，复制代码地址 使用如下命令下载主题到thems目录下 1git clone https:&#x2F;&#x2F;github.com&#x2F;justpsvm&#x2F;hexo-theme-primer.git themes&#x2F;primer 找到 _config.yml 末尾 如下位置，替换 thems目录下载的主题名称 再次执行三组命令 123hexo cleanhexo ghexo s 然后在github创建一个仓库，名称格式为； “用户名”.github.io 安装部署插件 1$ npm install hexo-deployer-git --save # 安装部署插件 修改部署配置 然后 执行如下一组命令 1234hexo cleanhexo ghexo shexo d 每次 修改完都需要执行如上命令重新发布； 浏览器输出 https://zszxz.github.io/ 显示如下说明搭建成功； 五hexo 命令常见命令 hexo new “postName” # 新建文章 hexo clean # 清除缓存 hexo generate # 生成静态页面至 public 目录 hexo server # 开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server） hexo deploy # 部署到 GitHub hexo help # 查看帮助 hexo version # 查看 Hexo 的版本 缩写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令 hexo s -g # 生成并本地预览 hexo d -g # 生成并上传 六后续迁移如果换电脑了，hexo的迁移也不困难，将 myblog 内容 存储至github，从另一台电脑拉取，内容如下 123456_config.ymlpackage.json.gitignorescaffolds&#x2F;source&#x2F;themes&#x2F; 之后安装hexo环境 1npm install -g hexo 安装依赖 1234567npm install将文章部署到github上的模块npm install hexo-deployer-git --save安装RSS插件npm install hexo-generator-feed --save添加Sitemap,加速网页收录速度npm install hexo-generator-sitemap --save 检查 12hexo ghexo s 最后如果写的不错，大家可以关注下我公众号：知识追寻者","path":"2020/11/13/分享/基于Hexo搭建个人博客/","date":"11-13","excerpt":"","tags":[{"name":"分享","slug":"分享","permalink":"https://zszxz.github.io/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"MYSQL索引(第十六讲)","text":"一什么是索引索引在MYSQL中也可以称为键，其是存储引擎用于快速查找记录的一种数据结构；这样听起来有点生涩，你可能难以理解；如果给你一本书，你如何能够精确的查找到书中某个章节的具体位置呢？我们肯定是先看目录，再找内容。你可以理解索引就像书的目录一样；当数据库的数据量大的时候，索引的性能对数据库非常重要，索引分为很多种，所以要学习好索引的相关知识，甚至比查询优化更重要。 二B-Tree与 B+Tree2.1B-tree树学习B-树之前读者肯定要有二叉树的基础知识，（没学过的看这篇 https://blog.csdn.net/youku1327/article/details/105159762） MYSQL中的数据结构实际上是B+tree，而非Btree；所以我们先要了解一下什么是Btree，再了解下一下什么是B+tree; 要得出的结论是为什么MYSQL要使用B+tree, 而非 Btree； M阶B-tree的特征如下 根节点至少有两个子女. 每个节点包含k-1个元素和k个孩子,其中m/2 &lt;= k &lt;= m. 每一个叶子节点都包含k-1个元素,其中m/2 &lt;= k &lt;= m. 所有的叶子节点位于同一层. 每个节点中的元素从小到大排列,那么k-1个元素正好是k个孩子包含的值域的划分 如果没学过数据结构的读者看到这边肯定一头雾水，知识追寻者还是做个简单的说明；如下图3阶B-树所示； 根节点9包含两个子节点，（3，7）一个节点，12 一个节点； (m/2=1) &lt;= k &lt;= (m=3); 所以节点包含1至3个都正确，故 （3，7）和 12 满足要求； 再看 2 小于 3 位于 3左侧，（4，5）大于3小于7位于（3，7）中间，8大于7位于7右侧； 树的高度决定了磁盘的IO能力，一棵3阶的B-磁盘IO能力为3，与二叉树IO能力相同；数据库加载索引的时候是加载磁盘页（默认4K大小），而非整个索引，每个磁盘页都对应索引的记录，故B-树并不能带来高效磁盘IO； 从树的形态上B-树比二叉树更加的胖，原因也很简单，B-树的节点可能包含多个元素； 注：B树就是B-树，面试的时候别说B减树； 2.2B+tree树B+树是B-树的基础上进行升级，B+树的特征如下 每个中间节点不保存数据，用来保存索引，叶子节点存放数据； 中间节点都存在于叶子节点，为最大值或者最小值，所以会出现重复的现象； 叶子节点之间根据自身的顺序进行了链接； 对B+树也做个简单说明： 中间节点 （2，5，8）和（11，16）都没有存放数据，并且都是叶子节点存放数据； 8，16同时存在于中间节点，叶子节点；同理（2，5，8）这个节点的元素都存在于叶子节点； 2.3B+比B-优势B+比B-的优势在哪里，面试经常问道； B+树的中间节点不存放数据，磁盘页可以存放更多的节点元素； B+Tree非叶子节点不存储数据，所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都一样；而B-树根据精确的匹配查找，查找数据不稳定； 三 索引3.1 非聚集索引和聚集索引MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚集索引（普通索引）和聚集索引； 聚集索引:聚集索引的顺序就决定了数据行的物理存储顺序；所以我们创建的主键索引其实就是聚集索引，如果未定义主键，MYSQL会默认选择非空的唯一索引当作主键，否则会默认生成一个主键 非聚集索引：索引顺序与数据行物理排列顺序无关； 看下普通索引如何创建，其作用就是加快查询速度； 语法格式如下 1alter table 表名 add index 索引名称(索引字段) 如果创建表的时候语法格式如下 1CREATE INDEX 索引名称 ON 表名 (索引字段) 知识追寻者手头有一张用户表，模拟10万数据； 未创建索引查询速度 123select * from sys_user where first_name = &#x27;ijklmnopqrs&#x27;&gt; OK&gt; 时间: 0.059s 创建索引 1alter table sys_user add index select_username(first_name) 创建索引后查询速度 123select * from sys_user where first_name = &#x27;ijklmnopqrs&#x27;&gt; OK&gt; 时间: 0.049s 删除索引 1DROP INDEX [索引名称] ON 表名; 查看索引 1SHOW INDEX FROM 表名; 3.2索引的分类Mysql中索引的种类也不是很多，不同类型的索引有不同的作用，索引的作用相互之间也存在交叉关系，Mysql中索引主要分为以下几类： 主键索引（PRIMARY KEY）：主键索引一般都是在创建表的时候进行指定，一个表只有一个主键索引，特点是唯一、非空。MYSQL常用就是 自增主键； 唯一索引（UNIQUE）：唯一索引具有的特点就是唯一性，即指定列不能出现重复数据； 前缀索引（prefix INDEX）：前缀索引建立的基础就指定列数据有很多的共同前缀； 联合索引：联合索引又称符合索引，是在表中两个或者两个列以上的基础上创建索引； 覆盖索引：当一个索引包含(或者说是覆盖)需要查询的所有字段的值时,我们称之为覆盖索引； 3.3 主键索引和唯一索引主键索引我们通常不默认，经常使用，一张表中仅允许有一个主键，可以由一个或者多字段组成；主键索引满足如下特征： 主键必须唯一； 主键不能包含NULL值； 主键必须自增； 创建主键语法格式 1alter table 表名 add primary key (字段名称) 创建唯一索引语法格式： 1alter table 表名 add unique (字段名称) 如果是创建表时添加约束语法格式 1CREATE UNIQUE INDEX 索引名称 ON 表名(字段(字段长度)); 3.4 前缀索引前缀索引: 当对字符串进行索引时,如果数据库中该字段有许多的前缀重复就可以使用前缀索引，,这样可以大大的节约索引空间,从而提高索引效率；但其缺点也很明显，不能在 order by 和 group by 中使用； 前缀索引经常使用在地名，比如 xx省xx市xx县这种情形，有一个统一的前缀 xx省xx市； 创建语法 1alter table 表名 add key (字段名称(前缀长度)) 示例 1alter table sys_user add key (first_name(8)) 查询的时候使用指定前缀的长度性能更加 1select * from sys_user where first_name &#x3D; &#39;ijklmnop&#39; 3.5 覆盖索引回表查询： MYSQL 如果只通过索引就可以返回查询所需要的数据，就是不是回表查询，否则查到索引数据后还需要回到表中查询数据就是回表查询； 我们来看个简单的示例 先去除前缀索引 1drop index first_name on sys_user 然后加上普通索引 1alter table sys_user add index select_username(first_name) 实行MYSQL执行计划 （没学过MYSQL执行计划看这篇 https://blog.csdn.net/youku1327/article/details/107336500） 1explain select id from sys_user where first_name &#x3D; &#39;ijklmnop&#39; 输出结果表示 使用using index ， 由于 id 和 first_name 都是索引；所以不需要回表查询就是覆盖索引； 如果我们使用如下语句则需要回表查询，原因是查询到字段id, first_name后还需要回表查询其它字段，这就是为什么 select * 如此慢的原因； 1explain select * from sys_user where first_name &#x3D; &#39;ijklmnop&#39; 输出结果如下 3.6 联合索引联合索引是在表中用2个或者2个以上的字段创建索引，其创建索引方式与普通索引相同；其能减小检索范围； 语法格式 1alter table 表名 add index 索引名称(字段1，字段2...) 最左前缀匹配原则 使用联合索引有一个非常重要的因素就是所有的索引列只可以进行最左前缀匹配原则； 比如 联合索引 first_name和 last_name 1alter table sys_user add index select_username(first_name,last_name) 根据最左匹配原则情形如下会命中索引 first_name,last_name first_name 转换为查询语句命中索引示例如下 123456789select * from sys_user where first_name &#x3D; &#39;ijklmnop&#39;;select * from sys_user where first_name &#x3D;&#39;ijklmnop&#39; and last_name &#x3D;&#39;ijklmnop&#39;;select * from sys_user where first_name &#x3D;&#39;ijklmnop&#39; and last_name in (ijklmnop&#39;);select * from sys_user order by first_name,last_nameselect * from sys_userwhere first_name &#x3D;&#39;ijklmnop&#39;order by last_name 如下情形不会命中索引 12select * from sys_user where last_name &#x3D; &#39;ijklmnop&#39;;select * from sys_userwhere last_name &#x3D;&#39;ijklmnop&#39;order by first_name 索引下推 Mysql5.6版本发布了索引下推的原则，主要用于like关键字的查询优化 ； 比如联合索引（last_name,age） 1select * from sys_user where last_name like &#39;ijklmnop&#39; and age&gt;&#39;20&#39;; 命中可能性如下 命中last_name联合索引，查询所有满足last_name以”ijklmnop”开头的数据， 然后回表查询所有满足的行。 命中last_name联合索引，查询所有满足last_name以”ijklmnop”开头的数据，然后再筛出age&gt;20的索引，再回表查询全行数据。 第二种方式的磁盘IO会更少，查询效率会更高，这就是下推索引； 除此之外还有全文索引和hash索引，简单了解一下即可； 四 索引总结4.1索引的优点 提高查询效率 提高聚合函数查询效率 提高排序查询效率 使用覆盖索引避免回表 4.2创建索引的策略 不要在NULL值列上使用索引，尽量使用NOT NULL约束列上使用索引 很少查询的字段不要使用索引 大数据类型字段不创建索引 4.3 使用索引时的注意事项 不要在条件NOT IN、&lt;&gt;、!= 等范围查询中使用索引 模糊查询时不要使用 %开头（ 如 ‘%xxx’ , ‘%xxx%’） 查询索引的字段不要函数计算 联合索引查询时遵循最左原则 全部扫描超过30%不会走优化器； 听说关注公众号 知识追寻者 的男孩子都找到了漂亮的女朋友，女孩子都找到了白马王子；当然索引并非查询优化的最佳原则，但在大多数情况下就已经足够使用；在大数据情况下通常要考虑分库分表；","path":"2020/11/11/数据库/MYSQL索引-第十六讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQLl执行计划(第十五讲)","text":"一 前言本篇是MYSQL进阶第三篇，SQL调优的前置知识之一；学习本篇的基础是知识追寻者发布的MYSQL系列文章； 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 《SQL-mysql游标与触发器》 《SQL-mysql用户权限管理》 《SQL-mysql架构入门》 《SQL-mysql锁等待与死锁》 《SQL-mysql操作json》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 执行计划概念执行计划（EXPLAIN）即表示MYSQL这条语句是如何执行，其执行顺序如何，使用到哪些索引，表之间的关联关系等；如何对一条查询语句实行执行计划？很简单，在查询语句上面加上explain 关键字即可； 示例 ： 1EXPLAIN SELECT * from sys_user where last_name = &#x27;ijklmnopqrs&#x27; 输出结果如下，总共有十二个字段，我们可以根据这12个字段给出的信息对SQL语句进行评估，然后进行调整优化我们的查询语句； 三 关键字段详解3.1id表示查询语句中的执行顺序，其值越大，优先级越高，被优先执行的可能性久越大； 示例： 1EXPLAIN SELECT * from `order` , oder_detail where `order`.id = oder_detail.oid 如上语句查询中涉及2张表，但它们id 是一致，故拥有执行的优先权一样； 示例： 1EXPLAIN select * from sys_user where id = &#x27;1&#x27; UNION (select * from sys_user ) 如上语句 出现了id 不同的，id 越大，越优先被执行，但也出现了情况id 为 null 3.2select_typeselect_type 表示 区分查询类型，通常用来判定该查询是简单查询还是复杂查询（子查询，联合查询等）； SIMPLE：表示不包含子查询或者UNION; PRIMARY: 包含子查询最外层的查询; SUBQUERY：当 select 或 where 列表中包含子查询; DERIVED：表示包含在from子句中的子查询; UNION : 表示union后边又出现的select 语句，则会被标记为union； UNION RESULT: 代表从union的临时表中读取数据, &lt;union 1,2&gt;表示从第一个查询和第二个查询的临时表中进行union操作； dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响 dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 3.3 table查询行的表名，也有可能是临时表； 3.4 typetype 联合查询使用的类型；SQL优化的重要指标之一； system：仅当只有一条数据时（系统表） const：表示 表中最多有一个匹配行 示例 ： 1EXPLAIN SELECT * from `order` where id = &#x27;1&#x27; 输出 eq_ref：关联查询时命中主键primary key 或者 unique key索引，必须是等值操作； 示例： 12EXPLAIN SELECT * from `order` , oder_detail where `order`.id = oder_detail.oid 输出 ref：非唯一索引列； 示例： 12EXPLAIN SELECT * from `order` where order_name = &#x27;小天使的订单&#x27; 输出 fulltext：使用到全文索引检索; ref_or_null：类似于ref，但是可以搜索包含null值的行; index_merge：关联查询使用了两个以上的索引 unique_subquery 在in中使用了子查询中某些时候会取代 ref; index_subquery : 与unique_subquery 类似，但非作用在唯一索引上； range：按范围来检索,比如 &gt; , &lt; , between….and ,in等 示例： 12EXPLAIN SELECT * from `order` where id &gt; &#x27;2&#x27; 输出 index：从索取树中查找，也属于全表扫描； 示例： 12EXPLAIN select id from `order` 输出 ALL：全表扫描; 示例： 1EXPLAIN select * from `sys_user` where last_name = &#x27;ijklmnopqrs&#x27; 输出 3.5 partitionspartitions 查询匹配到的分区，没有分区就是null； 示例： 12EXPLAIN select id from `order` 输出 3.6 possible_keys可能会使用到的索引 示例 1EXPLAIN SELECT * from `order` where order_name = &#x27;小天使的订单&#x27; 输出 3.7 keymysql中实际使用到的索引，否则为null； 示例 1EXPLAIN SELECT * from `order` where order_name = &#x27;小天使的订单&#x27; 输出 3.8 key_lengthkey_length ：表示查询用到的索引长度（字节数），越短越好 示例： 12EXPLAIN SELECT * from `order` where id =&#x27;9&#x27; 输出 3.9 ref const : 等值查询 func: 关联查询,使用了函数，表达式 null: 其它情况 3.10 rows扫描表的行，非精确值；一般情况下 rows 越小越好。 示例： 12EXPLAIN SELECT * from `order` where id =&#x27;9&#x27; 输出 3.11 extra扩展信息 Using index： 使用了覆盖索引; Using where: 使用了where 条件过滤数据； Using temporary：表示查询后结果需要使用临时表来存储; Using filesort: 排序时未使用到索引； Using join buffer：官联表查询的时候，表的连接条件没有用到索引； 更多扩展信息参考官网： https://dev.mysql.com/doc/refman/5.7/en/explain-output.htm 四 何时需要优化explain 执行计划的参数非常多我们一般是记不过来，于是筛选了一些性能极差的条件用作SQL优化标准，知识追寻者的认为如下情况是必须需要优化； 当type 出现all 为 全表扫描时一般需要优化 当 row 的数值 非常大，或接近全表时需要优化 extra 出现 Using filesort， Using temporary 时需要优化；","path":"2020/11/11/数据库/MYSQLl执行计划-第十五讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQLl操作json(第十四讲)","text":"一 前言MySQL 5.7.8 之后 支持 JSON （由rfc7159规定）数据类型，其能在字段中使用json 类型，做到了自动校验是否为json类型数据，否则插入数据会报异常；其次，储存json数据内部做到了优化储存，能够快速读取json类型数据，比如无需将二进制json转为文本形式后读取； 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 《SQL-mysql游标与触发器》 《SQL-mysql用户权限管理》 《SQL-mysql架构入门》 《SQL-mysql锁等待与死锁》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 操作 JOSN建表语句如下，为 area 字段 声明为 JSON 类型； 123456789CREATE TABLE `order` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;订单编号&#x27;, `order_name` varchar(255) DEFAULT NULL COMMENT &#x27;订单名称&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `year` year(4) DEFAULT NULL COMMENT &#x27;年份&#x27;, `area` json DEFAULT NULL COMMENT &#x27;地区&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `order_name` (`order_name`,`create_time`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; MySQL 中支持 json 对象 和json 数组，他们之间可以相互嵌套；json类似map，在java中json就是map得实现类，初学者若不懂何为json，就当作map来用，即储存 key - value 形式得数据结构；注意点是 json 数据 得key 必须是字符串，可以有key无value； 2.1 插入 josn数据插入 json 对象，east 得值 为 50 ， sourth 值为65 得 json对象； 12INSERT INTO `order`(`order_name`, `year`, `area`) VALUES (&#x27;荷小花的订单&#x27;, 2020, &#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27;); 等效于使用 JSON_OBJECT 函数， 示例如下 12INSERT INTO `order`(`order_name`, `year`, `area`) VALUES (&#x27;荷小花的订单&#x27;, 2020, JSON_OBJECT(&quot;east&quot;, &quot;50&quot;, &quot;south&quot;, &quot;65&quot;)); 插入 json 数组 12INSERT INTO `order`(`order_name`, `year`, `area`) VALUES (&#x27;荷小花的订单&#x27;, 2020, &#x27;[&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;]&#x27;); 等效于使用 JSON_ARRAY 函数，示例如下 12INSERT INTO `order`(`order_name`, `year`, `area`) VALUES (&#x27;荷小花的订单&#x27;, 2020, JSON_ARRAY(&quot;east&quot;, &quot;50&quot;, &quot;south&quot;, &quot;65&quot;)); 2.2 查询json数据使用 column - path 路径符 -&gt; 查询 指定key 得值， 1select order_name, area -&gt; &#x27;$.east&#x27; from `order` 注意，如果json 数据中不存在 east 得键，则列出为null值 输出如下 123--------- ------荷小花的订单 &quot;50&quot;荷小花的订单 也可以使用 -&gt;&gt; 符号, 不同之处是使用 -&gt;&gt; 更加直观，输出得json数据最外层不会携带双引号，内层数据中存在双引号不会有反斜杠转义； 1select order_name, area -&gt;&gt; &#x27;$.east&#x27; from `order` 使用 单引号 代替 双引号 12select order_name, area -&gt;&gt; &quot;$.east&quot; from `order` 我们 也可以使用 JSON_EXTRACT 函数 达到同样得效果； 12SELECT order_name,JSON_EXTRACT(area, &#x27;$.east&#x27;) from `order`; 2.3 修改json数据使用 JSON_SET 设置 json key 得 值 id = 1 得 area 数据如下 1&#123;&quot;north&quot;: &quot;55&quot;, &quot;south&quot;: &quot;66&quot;&#125; 现在将south 值改为 60 的语句示例如下 1update `order` set area = json_set(area, &#x27;$[0].south&#x27;, &#x27;60&#x27;) where id = &#x27;1&#x27; 其中 $[0] 代表 json 中的第一个对象 ,以此类推 $[1] 为 josn 中的第二个对象； 示例 1[&quot;6&quot;,&quot;2&quot;,&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;] $[0] 为”6”，$[1] 为 “2” , $[2] 为 {“east”: “50”, “south”: “65”}; $[2].east 为 “50” , 或者 $[2][1]; 如果上面$[*] 表达式式理解困难也可以使用如下方式 1update `order` set area = json_set(area, &#x27;$.south&#x27;, &#x27;60&#x27;) where id = &#x27;1&#x27; tip: 如果更改整个json值 与 平时的更新数据方式一致 2.4 删除json中的数据使用 json_remove 可以达到效果； 示例: 删除json 中的 south 键 1update `order` set area =json_remove(area, &#x27;$.south&#x27;) where id = &#x27;1&#x27; 三 jsom函数3.1 castcast 函数 是特殊函数，可以使用 CAST(expr AS type) 函数进行数据类型得转换，此函数 与 convert 用法 类似 ，即 期望得表达式转为期望得类型； 比如 将 字符串 知识追寻者从默认类型转为utf8类型 1SELECT CONVERT(&#x27;知识追寻者&#x27; USING utf8); 如下情况下查询是字符串，非json数据 12select &#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27; as str 再来看看 cast 函数使用，将字符串转为json 类型 1select cast( &#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27; as json ) 3.2 JSON_TYPEJSON_TYPE 函数 会尝试 去解析 参数为json值， 示例 1select JSON_TYPE(&#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27;) 得到结果为json 对象 1OBJECT 示例 1select JSON_TYPE(&#x27;[&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;]&#x27;) 得到结果为json数组 1ARRAY 示例 1select JSON_TYPE(&#x27;hello&#x27;) 输出为异常，无效得json 1Invalid JSON text in argument 1 to function json_type: &quot;Invalid value.&quot; at position 0. 3.3 JSON_MERGEJSON_MERGE 函数 即 将合并多个json文档； 合并规则如下 如果都是json array，合并为json array； 如果都是json object，合并为json object； 如果有多种类型数据，则将非json array的元素封装成json array再按照如上规则进行合并； 示例 12select json_merge(&#x27;[&quot;west&quot;,&quot;20&quot;]&#x27;, &#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27;) 输出 1[&quot;west&quot;, &quot;20&quot;, &#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;] 3.4 JSON_VALIDJSON_VALID 函数 为 校验是否是json 函数，是返回 1 ，否则 返回0； 示例如下，返回1； 1SELECT JSON_VALID(&#x27;&#123;&quot;east&quot;: &quot;50&quot;, &quot;south&quot;: &quot;65&quot;&#125;&#x27;) 示例如下，返回 0； 12SELECT JSON_VALID(&#x27;hello&#x27;) 3.5 JSON_INSERTJSON_INSERT 函数 向 json 中添加新的值，不会改变已经存在的值； id = 1 的数据如下 1&#123;&quot;north&quot;: &quot;55&quot;&#125; 更新语句如下 1update `order` set area =JSON_INSERT(area, &#x27;$.north&#x27;, 55 ,&#x27;$.south&#x27;, &quot;60&quot;) where id = &#x27;1&#x27; 更改结果如下 1&#123;&quot;north&quot;: &quot;55&quot;, &quot;south&quot;: &quot;60&quot;&#125; 3.6 JSON_REPLACEJSON_REPLACE 替换现有的值，如果存在新的值不会添加； id = 1 的数据如下 1&#123;&quot;north&quot;: &quot;55&quot;, &quot;south&quot;: &quot;60&quot;&#125; 更新语句如下 123update `order` set area =JSON_REPLACE (area, &#x27;$.north&#x27;, &quot;50&quot; ,&#x27;$.east&#x27;, &quot;60&quot;)where id = &#x27;1&#x27; 更改结果如下 1&#123;&quot;north&quot;: &quot;50&quot;, &quot;south&quot;: &quot;60&quot;&#125; 3.7 JSON_SEARCHJSON_SEARCH ， 返回路径，支持返回单个和返回多个； id = 1 的数据如下 1[&#123;&quot;north&quot;: &quot;50&quot;, &quot;south&quot;: &quot;60&quot;&#125;, &#123;&quot;north&quot;: &quot;50&quot;, &quot;south&quot;: &quot;70&quot;&#125;] 查询 一个值为 50 的key路径 12select JSON_SEARCH(area, &#x27;one&#x27;, &#x27;50&#x27;) from `order` where id = &#x27;1&#x27; 输出 1&quot;$[0].north&quot; 查询 所有值为 50 的key路径 1select JSON_SEARCH(area, &#x27;all&#x27;, &#x27;50&#x27;) from `order` where id = &#x27;1&#x27; 输出 1[&quot;$[0].north&quot;, &quot;$[1].north&quot;] 3.8 JSON_KEYS返回json顶级值底下所有key id = 1 的数据如下 1[&#123;&quot;north&quot;: &quot;50&quot;, &quot;south&quot;: &quot;60&quot;&#125;, &#123;&quot;north&quot;: &quot;50&quot;, &quot;south&quot;: &quot;70&quot;&#125;] 查询json数据中第一个json对象所有的key 1select JSON_KEYS(area, &#x27;$[0]&#x27;) from `order` where id = &#x27;1&#x27; 输出 1[&quot;north&quot;, &quot;south&quot;]","path":"2020/11/11/数据库/MYSQLl操作json-第十四讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL锁等待与死锁(第十三讲)","text":"一 前言本篇是MYSQL高级进阶篇内容第二篇，学习本篇的基础是知识追寻者之前发布过的文章，尤其是《MYSQL架构入门篇》重中之重； 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 《SQL-mysql游标与触发器》 《SQL-mysql用户权限管理》 《SQL-mysql架构入门》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 锁等待锁等待的意思非常好理解，就是session （事物会话，开启一个事物代表一个会话）A 对 某行数据获取独占锁（在这边一般就是写锁），然后session B 对相同的行进行获取独占锁就发生了锁等待；简单理解就是 小孩子抢玩具，谁先抢到 谁 先玩，没抢到的玩具的孩子只能 等待 抢到玩具孩子玩腻了再给你，瞬间泪奔有木有，就是这么残酷，当然MYSQL 没 这么残忍 其 还是有一个保留参数 innodb_lock_wait_timeout 指定死锁 的时间，如果超过 死锁等待时间就是报异常； 知识追寻者 做个实验： session A 执行如下语句，开启事物，更新索引为1 的语句；此时 session A 获取了 id= 1 这条 语句的 写锁权限； 12BEGIN;update `order` set `year`= &#x27;2022&#x27; where id = &#x27;1&#x27;; session B 执行如下 语句 , 跟 上面的语句一样 ，由于 id =1 这条数据的写锁已经被session A 获取，故会发生锁等待的情况； 12BEGIN;update `order` set `year`= &#x27;2022&#x27; where id = &#x27;1&#x27;; 知识追寻者这边默认等待了50秒 就报了如下异常 1Lock wait timeout exceeded; try restarting transaction 查看 默认锁等待 语句 1show VARIABLES like &#x27;innodb_lock_wait_timeout&#x27; 三 死锁3.1 死锁的产生死锁 就是 两个以上的会话 在 抢占 资源过程中 ，产生相互等待的情况；有点绕是不是，其实很简单 死锁是建立在 锁等待的基础上，session A 获取 id = 1 的写锁 ， session B 获取 id =2 的写锁 ，此时由于索引不同，故不会长生锁等待现象 ； 当 session A 尝试 获取 id =2 的 写锁时 ，由于 id = 2 写锁已经被 session B 获取 ，故产生锁等待；当 session B 尝试 获取 id = 1 的写锁时 ，由于id =1 写锁已经被 session A 获取, 此时 产生锁等待； 由于 session A 与 session B 同时 都在 锁 等待状态，产生了等待对方释放锁，故会产生死锁； 知识追寻者做个试验 session A 执行语句， 获取 id =1 的 写锁权限； 12BEGIN;update `order` set `year`= &#x27;2022&#x27; where id = &#x27;1&#x27;; session B 执行语句， 获取 id =2 的 写锁权限； 12BEGIN;update `order` set `year`= &#x27;2022&#x27; where id = &#x27;2&#x27;; session A 执行语句， 尝试获取 id =2 的 写锁权限，进入锁等待状态 1update `order` set `year`= &#x27;2022&#x27; where id = &#x27;2&#x27;; session B 执行语句， 尝试获取 id =1 的 写锁权限，进入锁等待状态 1update `order` set `year`= &#x27;2022&#x27; where id = &#x27;1&#x27;; 当 B 进入 锁等待后就直接报死锁异常 1Deadlock found when trying to get lock; try restarting transaction 3.2 查看死锁可以使用 show engine innodb status 查看死锁 123456789101112131415161718192021222324252627......*** (1) TRANSACTION: &#x2F;&#x2F; 事物ATRANSACTION 253507, ACTIVE 474 sec starting index readmysql tables in use 1, locked 1 &#x2F;&#x2F; 已经使用一个锁LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 17001, OS thread handle 139824777217792, query id 2191731 ......root updatingupdate &#96;order&#96; set &#96;year&#96;&#x3D; &#39;2022&#39; where id &#x3D; &#39;2&#39;&#x2F;&#x2F;执行得语句*** (1) WAITING FOR THIS LOCK TO BE GRANTED: &#x2F;&#x2F; 等待锁释放获取锁RECORD LOCKS space id 65 page no 3 n bits 80 index PRIMARY of table &#96;zszxz&#96;.&#96;order&#96; trx id 253507 lock_mode X locks rec but not gap waiting.....*** (2) TRANSACTION: &#x2F;&#x2F; 事物 BTRANSACTION 253508, ACTIVE 425 sec starting index readmysql tables in use 1, locked 1 &#x2F;&#x2F; 已经使用一个锁3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1MySQL thread id 17002, OS thread handle 139824778569472, query id 2191735 ......root updatingupdate &#96;order&#96; set &#96;year&#96;&#x3D; &#39;2022&#39; where id &#x3D; &#39;1&#39;&#x2F;&#x2F;执行得语句*** (2) HOLDS THE LOCK(S): &#x2F;&#x2F;持有锁RECORD LOCKS space id 65 page no 3 n bits 80 index PRIMARY of table &#96;zszxz&#96;.&#96;order&#96; trx id 253508 lock_mode X locks rec but not gap......*** (2) WAITING FOR THIS LOCK TO BE GRANTED: &#x2F;&#x2F; 等待锁释放获取锁RECORD LOCKS space id 65 page no 3 n bits 80 index PRIMARY of table &#96;zszxz&#96;.&#96;order&#96; trx id 253508 lock_mode X locks rec but not gap waiting...... 不得不说下字母代表锁得类型如下 共享锁（S） 排他锁（X） 意向共享（IS） 意向排他（IX） gap lock（GK）， 间隙锁，锁定一个范围，不包括当前记录本身； RECORD LOCKS 代表记录锁； 可以看见上面得语句 （1） 代表 事物A ，MYSQL 线程id 17001 ； (2) 代表事物B, MYSQL 线程id 17002 ； 事物 A 与B 都在等待 对方释放锁 ，产生了死锁； Tip； 查看表锁 : show status like ‘table%’; 如何解决死锁，知识追寻者这边给个思路： 查找到死锁线程，杀死MYSQL死锁的线程(kill命令)； 如果事物未提交，直接回滚事物； 3.3 如何避免死锁 在死锁容易产生得表使用表锁不会产生死锁； 避免交叉使用相同的锁","path":"2020/11/11/数据库/MYSQL锁等待与死锁-第十三讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQLl架构入门(第十二讲)","text":"一 前言本篇是关于mysql架构层面的内容，之前的知识追寻者发布的文章都是基础系列文章，如果读者们学习到这边就算是步入MYSQL的高阶内容了，你将理解什么MYSQL的架构与引擎，读写锁，等进阶知识，为以后的MYSQL参数配置，引擎选择，语句优化打下坚实的基础；学习本篇的内容是知识追寻者发布过的基础系列文章 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 《SQL-mysql游标与触发器》 《SQL-mysql用户权限管理》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 mysql 架构2.1 MYSQL架构概览MYSQL 的层级大概可以分为3类；第一层 为 连接层，只要负责MYSQL的数据库连接，安全认证的功能； 第二层是MYSQL的核心层面，其主要功能包括，MYSQL的查询，缓存，执行计划，优化等都在第二层实现； 第三层是引擎层，为MYSQL指定不同的引擎将达到不同的数据操作效果； 2.2 Query CacheMYSQL 的 Query Cache 是 基于 hash 值计算进行匹配的缓存机制；通常在大数据量的情况下如果开启Query Cache 会 频繁的计算Hash ，会增加性能的消耗，得不偿失，生产环境中建议关闭该选项； 可以使用 语句 show VARIABLES like &#39;%query_cache%&#39; 查看 Query Chach 是否关闭；我们主要关注的是 参数 query_cache_type 是否关闭 ，如果是OFF就是关闭状态，ON是开启状态；而不是 query_cache_size参数，其是缓存分配大小；更多关于 Query Chach 的内容可以参考如下文章 https://blog.csdn.net/dongnan591172113/article/details/52084041 https://www.jianshu.com/p/3ab10180fbd5 2.3 读锁关于锁的知识希望读者学习过高并发相关知识，对所有的锁分类有个清晰的认识，学习本篇关于锁的概念将不会遇到阻碍；在MYSQL中根据不同的引擎，主要会出现三类锁的情况，即 表锁，读锁 和写锁；读锁很好理解，在MYSQL 中 读锁也是共享锁, 即 多用户状态下同一时间对资源的读取是互不影响，但不能对数据进行修改等操作； 一般情况下我们手动给一条或者某个范围内(一般使用在储存过程)的数据加上读锁； 使用语法示例如下 1SELECT 字段 from 表名 [where 条件] lock in share mode; 2.4 写锁写锁是排他锁，也称为独占锁；使用的情况一般是写入数据的情况下，一个用户如果获得写锁，其它用户将不能获取写锁或者读锁，直到该用户执行完操作并释放锁；其使用方式为在执行语句后加上for update 语句即可 格式示例 1SELECT 字段 from 表名 [where 条件] for update; 2.5 锁粒度锁粒度是指对资源锁定范围的一个程度，使用不同的锁定策略达到并发性能较优的结果；通常锁粒度使用策略情况分为，行锁，表锁，页锁的情况； 表锁：即对整张表进行加锁，其性能开销较小，加锁的速度较快，但缺点也很明显，其锁粒度大，并发低；如果要手动加表锁，语法示例 lock tables 表名，释放锁 unlock tables 表名； 行锁：即对行进行锁定，能够最大支持并发量，故锁粒度最小，但其枷锁速度慢，性能消耗大，会出现死锁；行锁的种类又有 记录锁（主键或者唯一索引都属于记录锁），间隙锁（GAP），记录锁和间隙锁的组合（next -key lock）；间隙锁一般用于查询条件是范围情况下，而非相等条件； 页锁：通常情况下遇不到页锁，其开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间； Tip: MyISAM和 Memory 引擎 支持表锁，其会自动给SELECT,UPDATE,INSERT,DELETE 自动加表锁；InnoDB 支持表锁和行锁，对于UPDATE, INSERT ,DELETE 语句 InnoDB 会自动给数据加排他锁，SELECT语句不加锁； 还有锁的其它分类也会使用到比如乐观锁（基于版本号实现），注意点是条件必须是主键，读取时将数据版本号读出，更新数据时，版本号加1；将查询的数据进行对比，如果版本号不一致就是过期数据； 查询示例 1select id,value,version from 表名 where id &#x3D; #&#123;id&#125; 更新示例 123update 表名set value&#x3D;2,version&#x3D;version+1where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125; 悲观锁（如表锁，行锁，读写锁都是悲观锁）； 如果看了知识追寻者写的锁知识还有困惑可以参考如下链接 https://juejin.im/post/5b82e0196fb9a019f47d1823 2.6 引擎简介在上面的图例中可以看见MYSQL支持多种引擎，当然远不止图中显示的引擎数量；我们主流使用的引擎就是 InnoDB,其次是 MyISAM，特殊情况下会使用到Memory；引擎的知识是一本书都无法概括的内容，知识追寻者在这边给小伙伴们做个简介，有个大概的了解就好； InnoDB 是使用最广泛的引擎，也是最重要的引擎，读者有必要了解其储存性能；InnoDB 是 可重复读的事物隔离级别，但其实现了next key lock ，防止的幻读出现；其基于聚簇索引实现；其组要组成结构为内存结构，线程，磁盘文件组； MyISAM在早期版本是MYSQL的默认引擎，在MYSQL5.1之后不再使用；其不支持事物，不支持行锁，默认表锁，并发量低，； Menory引擎故名思意，其储存内容都是存放在引擎当中，支持Hash和Btree索引，其数据读取快，但缺点也很明显，服务器如果发生故障重启后就会造成数据丢失；","path":"2020/11/11/数据库/MYSQLl架构入门-第十二讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL用户权限管理(第十一讲)","text":"一 前言本篇内容是关于MYSQL 数据库管理系统对数据库用户的权限相关的操作；学习本篇的基础是知识追寻者之前发布的MYSQL系列文章（公众号读者看专辑） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 《SQL-mysql游标与触发器》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 用户操作有关用户账号的信息储存mysql的MYSQL数据库，故如果需要查看用户信息，则需要进入MYSQL库； 2.2查看用户信息user表储存了所有的登陆账号；使用mysql库查询user表中的user； 12use mysql;select `user` from user; 打印 123456user----rootmysql.sessionmysql.sysroot 2.3 创建用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码 示例：创建用户 zszxz ,并指定密码为 zszxz； 1create user zszxz IDENTIFIED by &#x27;zszxz&#x27;; 2.4 重名名用户rename user 旧的用户名 to 新的用户名; 示例重命名 用户 zszxz 为 lsc 1rename user zszxz to lsc; 2.5 删除用户drop user 用户名 示例：删除用户lsc 1drop user lsc; 2.6 更改密码SET PASSWORD FOR 用户名 = PASSWORD(&#39;密码&#39;) 示例： 为用户 zszxz 更改密码为 lsc 1SET PASSWORD FOR zszxz = PASSWORD(&#x27;lsc&#x27;) 三 权限操作3.1 查看用户权限SHOW GRANTS FOR 用户名 示例： 查看用户zszxz 拥有的权限 1SHOW GRANTS FOR zszxz 打印 123Grant for zszxz@%----------------GRANT USAGE ON *.* TO &#x27;zszxz&#x27;@&#x27;%&#x27; 查询出一条权限，但 USAGE 表示 根本没有权限； 3.2 授予权限GRANT 权限 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#39;password&#39;] 常见的权限 all, create, drop, insert, update, delete,select； 示例 给用户zszxz 分配 zszxz 库中的所有表的查询权限； 1grant select on zszxz.* to zszxz; 再看下 zszxz变成 2 条 1234Grant for zszxz@%----------------GRANT USAGE ON *.* TO &#x27;zszxz&#x27;@&#x27;%&#x27;GRANT SELECT ON `zszxz`.* TO &#x27;zszxz&#x27;@&#x27;%&#x27; 3.3 撤销权限REVOKE 权限列表 ON 表名 FROM 用户名； 示例：撤销 用户 zszxz 对 zszxz库里面所有表的查询操作； 1revoke select on zszxz.* from zszxz 3.4 权限列表使用授权，撤销权限时可以参考如下权限列表； 123456789101112131415161718192021222324252627ALL --- 除GRANT OPTION外的所有权限ALTER ---使用ALTER TABLEALTER ROUTINE ---使用ALTER PROCEDURE和DROP PROCEDURECREATE ---使用CREATE TABLECREATE ROUTINE ---使用CREATE PROCEDURECREATE TEMPORARY TABLES ---使用CREATE TEMPORARY TABLECREATE USER ---使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGESCREATE VIEW ---使用CREATE VIEWDELETE ---使用DELETEDROP ---使用DROP TABLEEXECUTE ---使用CALL和存储过程FILE ---使用SELECT INTO OUTFILE和LOAD DATA INFILEGRANT OPTION ---使用GRANT和REVOKEINDEX ---使用CREATE INDEX和DROP INDEXINSERT ---使用INSERTLOCK TABLES ---使用LOCK TABLESPROCESS ---使用SHOW FULL PROCESSLISTRELOAD ---使用FLUSHREPLICATION CLIENT ---服务器位置的访问REPLICATION SLAVE ---由复制从属使用SELECT ---使用SELECTSHOW DATABASES ---使用SHOW DATABASESSHOW VIEW ---使用SHOW CREATE VIEWSHUTDOWN ---使用mysqladmin shutdown（用来关闭MySQL）SUPER ---使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录UPDATE ---使用UPDATEUSAGE ---无访问权限","path":"2020/11/11/数据库/MYSQL用户权限管理-第十一讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL游标与触发器(第十讲)","text":"一 前言本篇内容是关于mysql游标和触发器的知识，学习本篇的基础是知识追寻者之前发过的文章（公众号读者看专辑） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 《SQL-mysql储存过程》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 游标2.1 游标的概念游标的本质就是查询后的结果集；当我们对查询的结果集进行前一行或者后一行类似的操作时就可以使用到游标 2.2 游标的语法 首先需要 定义游标； declare 游标名称 cursor for 查询语句； 其次，打开游标； open 游标名称 然后，对查询的结果集 即游标进行 检索行至变量提供使用 最后关闭游标； close 游标名称 2.3 使用游标准备的表 1234567CREATE TABLE `oder_detail` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `detail_name` varchar(255) DEFAULT NULL COMMENT &#x27;订单明细&#x27;, `price` decimal(10,2) DEFAULT NULL COMMENT &#x27;价格&#x27;, `oid` int(11) DEFAULT NULL COMMENT &#x27;订单id&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT=&#x27;订单明细表&#x27;; 准备的数据 123456INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (1, &#x27;毛巾&#x27;, 20.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (2, &#x27;牙膏&#x27;, 15.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (3, &#x27;杯子&#x27;, 5.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (4, &#x27;毛巾&#x27;, 15.00, 2);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (5, &#x27;杯子&#x27;, 15.00, 2); 简单的使用游标 查询oid为1 的订单明细名称 的结果集作为游标； 打开游标后抓取每行将结果赋值给变量name 12345678910111213CREATE PROCEDURE printName()BEGIN -- 订单名称 declare name varchar(20); -- 创建游标 declare cur cursor for select detail_name from oder_detail where oid = &#x27;1&#x27;; -- 打开游标 open cur; fetch cur into name; select name; -- 关闭游标 close cur;END; 调用储存过程 1call printName; 打印结果如下，只有一条数据，说明上述方式只在游标中抓取到一条数据，而且是表里面行号最小的行； 123name------毛巾 在循环中使用游标 将 查询oid为1的 结果集赋值给游标；通过游标抓取每行 将 订单明细名称和价格分别赋值给变量 name 和 detail_price; 在 循环无法继续时 会出现 SQLSTATE ‘02000’ ; 即此通过 变量 continue 时设置 done 为1 代表 true，此时循环结束，跳出循环； 123456789101112131415161718192021222324252627282930drop procedure if exists printDetail;CREATE PROCEDURE printDetail()BEGIN -- 订单名称 declare name varchar(20); -- 价格 declare detail_price decimal(8,2); -- 结束标志变量（默认为假） declare done boolean default 0; -- 创建游标 declare cur cursor for select detail_name,price from oder_detail where oid = &#x27;1&#x27;; -- 指定游标循环结束时的返回值 declare continue HANDLER for SQLSTATE &#x27;02000&#x27; set done = 1; -- 打开游标 open cur; -- 循环游标数据 detail_loop:loop -- 根据游标当前指向的一条数据 fetch cur into name,detail_price; select name , detail_price; -- 判断游标的循环是否结束 if done then -- 跳出游标循环 leave detail_loop; end if; -- 结束游标循环 end loop; -- 关闭游标 close cur;END; 调用储存过程 12-- 调用存储过程call printDetail(); 美中不足的是会多遍历最后一行，如果要精细处理还是需要自定义标志位进行跳出循环； 三 触发器3.1触发器的概念触发器是指当表发生改变的时候触发的动作；听起来有点抽象，举个栗子，当你往表中插入数据的时候，此时表发生了改变，现在想要在每次插入数据之前检测所有的入参是否都是小写，此时就可以用触发器来检测；经过上面的分析知道使用一个基本的触发器，至少表要发生改变，还要满足一个被触发的事件； 表发生改变通常指 增删改，其动作可以发生在增删改 之前或者之后；触发事件就是我们需要写的储存过程； update (after/ before) insert (after/ before) delete (after/ before) 3.2 触发器的基本语法 创建触发器： create trigger 触发器名称 触发动作 on 表名 for each row [触发事件] 删除触发器：drop trigger 触发器名称； 查看触发器：show triggers; tip : 触发器是依赖于表创建，没有表就没有触发器，比如视图，临时表都不是真实的表，它们是没有触发器；一般来说每个表都有触发器的限制，一般最多支持6个不同类型的触发器；由于使用触发器会频繁的改变表的每行，故其十分影响性能，特别对一些更新频率比较快的大表，如果设置触发器就非常占用系统资源；一般来说触发器用在表变动较小的小表, 不使用触发器就立即删除； 3.3 insert 触发器示例创建触发器; 创建一个触发器 getPrice 作用于 oder_detail 表的每行，每当 插入数据之后就查询这条订单明细的价格赋值给变量 @price ；小伙伴可能会疑惑 NEW 是何物，其是一张虚表，记录者被插入数据的行；故我们能在NEW表中获取每次插入的数据； 123-- insert 触发器CREATE TRIGGER getPrice AFTER INSERT ON oder_detail FOR EACH ROWSELECT NEW.price INTO @price; 检测插入触发器; 插入一条数据，使用查询语句查询变量 显示为 20； 12345-- 检测插入触发器INSERT INTO `oder_detail`( `detail_name`, `price`, `oid`) VALUES ( &#x27;脸盆&#x27;, 20.00, 2);select @price; 删除触发器; 12-- 删除触发器drop trigger getPrice; 3.4 update 触发器示例将插入后触发器改为更新后的触发器如下 ， 只需要改动 after insert 为 after update 即可； 12CREATE TRIGGER getPrice AFTER update ON oder_detail FOR EACH ROWSELECT NEW.price INTO @price; 将之前的插入的SQL语句进行修改价格,并查询价格,此时价格为30；NEW虚表储存的是即将更新的数据； 123UPDATE `oder_detail` SET `price` = 30.00 WHERE `id` = 6;select @price; 删除触发器 12-- 删除触发器drop trigger getPrice; 将 更新触发器的NEW表改为OLD表 12CREATE TRIGGER getPrice AFTER update ON oder_detail FOR EACH ROWSELECT OLD.price INTO @price; 更新价格为40 1UPDATE `oder_detail` SET `price` = 40.00 WHERE `id` = 6; 此时查询 价格为30，说明OLD表触发的是原始数据值； 1select @price; tip ： 更新触发器主要是要搞懂OLD存放原始数据，NEW存放即将更新的数据；NEW表可以设置更改值，二OLD表是只读； 3.5 delete 触发器将 更新触发器改为 delete 触发器, 之前我们省略了 begin, end 如果是多条执行语句则需要加上； 1234CREATE TRIGGER getPrice AFTER delete ON oder_detail FOR EACH ROWbegin SELECT OLD.price INTO @price;end; 删除之前的SQL数据 1delete from oder_detail where `id` = 6; 查询价格为40，OLD表存放的是将要被删除的数据； 1select @price;","path":"2020/11/11/数据库/MYSQL游标与触发器-第十讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQLl储存过程(第九讲)","text":"一 前言本篇内容是关于mysql储存过程的知识，学习本篇的基础是知识追寻者之前发过的文章（公众号读者看专辑） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-mysql视图的前世今生》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 储存过程2.1 储存过程的概念我们经常使用的SQL查询语句都是单条语句，如果要使用多条语句达到一个目的就显得力不从心了，储存过程就是使用多条语句完成业务的操作，你可以理解为linux脚本编程类似，window的批处理文件那样；简单的定义储存过程就是多条SQL的集合； 我们使用储存过程能够简化复杂的单条SQL，相比于单条复杂的SQL极大提高了性能；如果表结构发生变化只需要改变储存过程使用到SQL语句的表名，如果业务逻辑发生变化，只需要跳转储存过程即可，具有很强的灵活性；建立一次储存过程，即可使用，不用反复建立，保证开发人员使用到都是相同的储存过程，保证数据可靠性；总之使用储存过程，简单，灵活，安全可靠，性能好； 2.2 存储过程语法 创建存储过程 1234Create PROCEDURE 储存过程名称 （参数列表）begin 过程体end; ​ 参数列表 12345IN 表示输入; 示例 IN var1 Decimal(6,2)OUT 表示输出;示例 IN var2 Decimal(6,2)INOUT 表示输入输出；示例 IN var3 Decimal(6,2) 变量 1declare 变量名称 变量类型 [default value] 执行存储过程 1call 储存过程名称 删除储存过程 1DROP PROCEDURE 储存过程名称 赋值 123使用 set 和 select into 语句为变量赋值。set @var := 20select sum(price) into total from table_name if 语句 12345678f 条件 then 表达式 [elseif 条件 then 表达式]...[else 表达式]end if; case语句 12345CASE 值 WHEN 匹配值 THEN 结果[WHEN 匹配值 THEN 结果]......[ELSE 结果]END while语句 1234[开始标签:]while 条件 do 循环体[结尾标签] end while ; loop 语句 1234[开始标签:] loop 语句体[结尾标签] end loop; iterate/ leave语句 1其是通过标签可以实现；iterate 表示迭代， leave表示离开 repeat语句 1234repeat--循环体until 循环条件 end repeat; tip : 如果你是用命令行学习，在写多行SQL的时候 使用 // 可以实现换行哟！ 2.3 储存过程示例我们准备表如下，一个订单明细表； 1234567CREATE TABLE `oder_detail` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `detail_name` varchar(255) DEFAULT NULL COMMENT &#x27;订单明细&#x27;, `price` decimal(10,2) DEFAULT NULL COMMENT &#x27;价格&#x27;, `oid` int(11) DEFAULT NULL COMMENT &#x27;订单id&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#x27;订单明细表&#x27;; 准备数据如下 123456INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (1, &#x27;毛巾&#x27;, 20.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (2, &#x27;牙膏&#x27;, 15.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (3, &#x27;杯子&#x27;, 5.00, 1);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (4, &#x27;毛巾&#x27;, 15.00, 2);INSERT INTO `zszxz`.`oder_detail`(`id`, `detail_name`, `price`, `oid`) VALUES (5, &#x27;杯子&#x27;, 15.00, 2); 无参储存过程 查看订单明细的所有订单名称,示例如下，跟普通的查询语句没区别； 1234create procedure slelect_detail()begin select detail_name from oder_detail;end; 我们再调用储存过程 1call slelect_detail(); 此时就会打印内容如下 12345毛巾牙膏杯子毛巾杯子 删除储存过程 1drop procedure slelect_detail; 带入参储存过程示例 现在我们需要查询oid为动态的所有订单明细名称，由于考虑到oid为动态，就是需要用户自己输入，故将oid作为入参; 1234create procedure slelect_detail(IN order_id INT)begin select detail_name from oder_detail where oid = order_id;end; 调用储存过程，只查询oid为1的用户的订单明细名称 1call slelect_detail(1); 打印内容 123毛巾牙膏杯子 删除储存过程 1drop procedure slelect_detail; 带入参和出参的存储过程示例 查询任意用户的订单明细的所有金额；定义入参订单id 为 order_id ， 输出总金额为 total； 1234create procedure slelect_toatal_money(IN order_id INT, OUT total DECIMAL(8,2))begin select sum(price) into total from oder_detail where oid = order_id;end; 调用储存过程示例 1call slelect_toatal_money(1,@total); 查询 order_id 为1 总金额示例 1SELECT @total; 输出为 40； 删除储存过程 1drop procedure slelect_toatal_money; 2.4 if 语句示例上节的储存过程都是单条SQL，这次我们开始使用控制流程，实现复杂的储存过程； 知识追寻者对输入的 order_id 自动加5 ，然后判断 var 是否 小于7 ，如果是就查询订单明细价格，否则查询订单明细价格总和； 12345678910111213create procedure slelect_toatal_money(IN order_id INT)begin -- 定义变量 declare var int; -- 赋值 set var&#x3D; order_id+5; -- if 判断 if var&lt;7 then select price from oder_detail where oid &#x3D; order_id; else select sum(price) from oder_detail where oid &#x3D; order_id; end if;end; 调用 1call slelect_toatal_money(1); 输出 1234price20155 调用 1call slelect_toatal_money(2); 输出 12sum(price)30 2.6 while 语句示例对 变量 var 进行判断，如果 var &lt;7 就执行 查询价格语句，并且var 进行自增； 123456789101112create procedure slelect_toatal_money(IN order_id INT)begin -- 定义变量 declare var int; -- 赋值 set var= order_id+5; -- while while var&lt;7 do select price from oder_detail where oid = order_id; set var = var + 1; end while;end; 调用示例 1call slelect_toatal_money(1); 输出 1234price 20155 2.7 case语句示例如下语句实现的效果与上面if语句实现效果一致； 1234567891011121314create procedure slelect_toatal_money(IN order_id INT)begin -- 定义变量 declare var int; -- 赋值 set var:= order_id; -- case 判匹配 case var when 1 then select price from oder_detail where oid = order_id; when 2 then select sum(price) from oder_detail where oid = order_id; end case;end; 调用示例 1call slelect_toatal_money(2); 输出 12sum(price)30 将参数改为1试试结果 2.8 loop语句如果 var 小于3 就 计算 价格 + var 的值； 12345678910111213141516create procedure slelect_toatal_money(IN order_id INT)begin -- 定义变量 declare var int; -- 赋值 set var:= order_id; -- loop select_loop : loop select price+var from oder_detail where oid = order_id; set var = var +1; -- 跳出循环 if var &gt; 3 then leave select_loop; end if; end loop;end; 调用示例 1call slelect_toatal_money(1); 会输出三组结果 2.7 repeatrepeat 与 while 的不同之处就是 ，while 在 执行之前检查条件，其实执行之后检查条件； 12345678910111213create procedure slelect_toatal_money(IN order_id INT)begin -- 定义变量 declare var int; -- 赋值 set var= order_id+5; -- repeat循环 repeat select price from oder_detail where oid = order_id; set var = var + 1; until var&gt;7 end repeat;end; 调用示例 1call slelect_toatal_money(1); 此时会输出2组相同结果； 1234price20155 tip: loop, while , repeat , iterate 都是循环，loop,while, repeat 功能几乎相同；iterate可以通过标签的形式调用 循环，与 leave 语句使用方式一样； 关注知识追寻者：","path":"2020/11/11/数据库/MYSQLl储存过程-第九讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL视图(第八讲)","text":"一 前言本篇内容是关于视图的一些概念，和使用，主要目的带小伙伴们全面的了解视图，而不是仅仅停留在简单的使用上 学习本篇的基础是知识追寻者发过SQL的系列文章，知识追寻者的目标是MYSQL系列知识直接安排，不管是学习和工作，学了直接能用；（公众号读者看专辑） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 《SQL-Mysql表结构操作》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 视图2.1 视图的概念视图其实就是一张虚表，其本质上SQL的检索语句，所以其不储存任何的数据成分；我们使用视图有什么好处呢？ 简化查询SQL，直接对视图进行查询，不用管视图具体生成的细节； 可以使用表的部分成为视图，保护数据，开放用户权限时，可以只开放视图，而不开放实体表； 修改数据结构，可以直接对已有的表建立视图，使用不同的表名，字段名称； 我们对视图的操作只能停留在查询上，如果是单表生成的视图还可以进行插入数据；如果是多表关联生成的视图，插入不会起作用；切记任何时候进行关联的时候如果关联3张表以上就是不符合规范，严重的拖累查询性能，视图也是如此，使用复杂的嵌套视图和多表关联也会极大的降低查询性能； 2.2 视图的规范 视图是虚表，其有表的部分特性；视图名 唯一 ，与表名类似； 如果非管理员用户，创建视图必须有创建权限； 视图本质是查询语句，故视图可以嵌套，可以与其它表进行联结； 视图不能有索引和触发器 2.3 视图语句小伙伴们要记得使用视图之前要看看自己的MYSQL版本，5.0以上支持； 创建视图 与创建表类似 ， create view 语句用于创建视图 显示视图创建语句 使用 show create view viewName ； 删除视图 使用语句 drop view viewName 更新视图 使用语句 create or replace view 2.4 视图操作我们的准备表如下 1234567CREATE TABLE &#96;order&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;订单编号&#39;, &#96;order_name&#96; varchar(255) DEFAULT NULL COMMENT &#39;订单名称&#39;, &#96;create_time&#96; datetime DEFAULT NULL COMMENT &#39;创建时间&#39;, &#96;year&#96; year(4) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8; 准备数据如下 1234INSERT INTO &#96;zszxz&#96;.&#96;order&#96;(&#96;id&#96;, &#96;order_name&#96;, &#96;create_time&#96;, &#96;year&#96;) VALUES (1, &#39;知识追寻者的订单&#39;, &#39;2020-03-04 11:01:25&#39;, 2019);INSERT INTO &#96;zszxz&#96;.&#96;order&#96;(&#96;id&#96;, &#96;order_name&#96;, &#96;create_time&#96;, &#96;year&#96;) VALUES (2, &#39;小天使的订单&#39;, &#39;2020-03-04 11:01:25&#39;, 2020);INSERT INTO &#96;zszxz&#96;.&#96;order&#96;(&#96;id&#96;, &#96;order_name&#96;, &#96;create_time&#96;, &#96;year&#96;) VALUES (3, &#39;流浪者的订单&#39;, &#39;2020-03-04 11:02:50&#39;, 2020); 新建简单的视图示例如下，使用 order 表 的 id , order_name , year 三个字段组成视图；as 后面就是查询语句，也可以是子查询，多表关联等复杂的查询语句； 1create view &#96;zszxz_order&#96; as SELECT &#96;id&#96; , &#96;order_name&#96;, &#96;year&#96; from &#96;order&#96; 查询视图，其使用本质与查询表一样；示例如下 1SELECT * from &#96;zszxz_order&#96; 向视图中插入数据，插入的数据实际在实体表 order 表中切记； 1INSERT INTO &#96;zszxz_order&#96;(&#96;order_name&#96;, &#96;year&#96;) VALUES (&#39;小凡汐的订单&#39;, 2020); 删除视图 1drop view &#96;zszxz_order&#96; 2.5 小结视图的本质上查询语句，故可以对一些简单的数据统计做成视图是个不错的选择；其次如果是开放权限给第三方公司，使用视图查询部分实体表的数据作为开放的表也是对视图的合理应用；最后，也可以将简单的表联结做成视图，简化开发； 由于视图的本质是查询语句，你可以理解为其前世就是查询，今生就是虚表，徒有其“表”，名不副实，只拥有表的部分功能； 关注知识追寻者：","path":"2020/11/11/数据库/MYSQL视图-第八讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL表结构操作(第七讲)","text":"一 前言本篇内容是关于 基本的数据库操作，建表，表结构修改等内容； 学习本篇的基础是知识追寻者以前发布的文章： 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 《SQL-Mysql数据类型》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 SQL 分类操作2.1 SQL 分类sql 对数据库的操作分为如下三种类型，如果都学会这三种SQL语言熟练对数据库操作，说明你已经对数据库登堂入室，如果再学会数据库高级操作，说明你对数据库就有一定的使用经验，如果你还学会对数据库进行优化，分表分库，读写分离等操作，说明你使用数据库已经到专家级别； DDL：数据定义语言（Data Define Language），即定义数据的结构。比如：create，drop，alter操作 DML：数据管理语言（Data Manage Language），即增删改查。比如：insert，delete，update，select。这个也在之前的文章详细写过，不再提及； DCL：数据控制语言（Data Control Language），对权限、事务等的控制。比如：grant（授权）revoke（取回权限），commit，roolback等; 事物在上篇已经说明，不会在本篇提及； 2.2 数据库基操数据库的基本操作如下，也就是我们日常使用的操作 连接数据库： mysql -h 地址 -P 端口 -u 用户名 -p 密码； 1mysql -h 192.168.0.127 -P 3306 -u root -p root 查看当前数据库： 1SELECT DATABASE(); 显示用户活动线程： 1SHOW PROCESSLIST; 显示系统变量： 1SHOW VARIABLES; 显示当前时间，用户，数据库版本号 1SELECT now(), user(), version(); 创建数据库：CREATE DATABASE[ IF NOT EXISTS] 数据库名 [数据库选项] 1234数据库选项： CHARACTER SET 字符集名称 COLLATE 排序规则名称示例：create database zszxz; 删除数据库： DROP DATABASE [ IF EXISTS] 数据库名; 1drop database zszxz; 2.3 建表语句数据库表的日常操作如下 1CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 ) [ 表选项] 其中 TEMPORARY 表示临时表；中括号内容都表示可选，在正规的数据库版本管理开发会经常使用到； 字段的修饰如下 数据类型 非空|空约束：[NOT NULL | NULL] 默认值：[DEFAULT default_value] 自动增长：[AUTO_INCREMENT] 唯一键|主键：[UNIQUE [KEY] | [PRIMARY] KEY] 备注：[COMMENT ‘string’] 表选项一般就是指定数据库引擎和字符集： 1ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;顾客表&#39;; 示例 12345678CREATE TABLE IF NOT EXISTS &#96;customer&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;, &#96;customer_name&#96; varchar(255) DEFAULT NULL COMMENT &#39;顾客名称&#39;, &#96;gender&#96; varchar(255) DEFAULT NULL COMMENT &#39;性别&#39;, &#96;telephone&#96; varchar(255) DEFAULT NULL COMMENT &#39;电话号码&#39;, &#96;register_time&#96; timestamp NULL DEFAULT NULL COMMENT &#39;注册时间&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;顾客表&#39;; 2.4 修改表结构查看所有表 1SHOW TABLES 查看指定数据库的表 12SHOW TABLES FROM 数据库名称;示例：SHOW TABLES FROM zszxz; 删除表 12DROP TABLE[ IF EXISTS] 表名;示例: drop table op; 清空表(清除数据) 1TRUNCATE [TABLE] 表名 复制表结构 12CREATE TABLE 表名 LIKE 要复制的表名;示例: create table op like `order`; 复制表结构和数据 12CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名;示例: CREATE TABLE op AS SELECT * FROM &#96;order&#96;; 常见的alter操作如下： 增加一列(追加至末尾) 12alter table [数据库名.]表名 add [column] 字段 数据类型;示例： alter table &#96;order&#96; add column &#96;year&#96; year ; 增加到第一列 1alter table [数据库名.]表名 add [column] 字段 数据类型 first; 增加一列到指定字段名后 1alter table [数据库名.]表名 add [column] 字段 数据类型 after 另一个字段; 修改字段名的 数据类型 12alter table [数据库名.]表名称 modify [column] 字段名 新的数据类型;示例： altert table &#96;order&#96; modify column &#96;gender&#96; tinyint; 修改表字段的数据类型，并且移动至第一列 1alter table [数据库名.]表名称 modify [column] 字段名 数据类型 first; 修改表字段的数据类型，并且移动至指定字段后面 1alter table [数据库名.]表名称 modify [column] 字段名 数据类型 after 另一个字段名; 修改表字段的名称 1alter table [数据库名.]表名称 change [column] 旧字段名 新的字段名 数据类型; 添加主键 12alter table [数据库名.]表名称 ADD PRIMARY KEY(字段名);示例： altert table &#96;order&#96; add primary key(&#96;id&#96;) 添加唯一键 1alter table [数据库名.]表名称 ADD UNIQUE [索引名] (字段名) 添加索引 1alter table [数据库名.]表名称 ADD INDEX [索引名] (字段名) 删除一列 12alter table [数据库名.]表名称 drop [column] 字段名;示例：altert table &#96;order&#96; drop column &#96;gender&#96;; 删除索引 1alter table [数据库名.]表名称 DROP INDEX 索引名 删除主键 1alter table [数据库名.]表名称 DROP PRIMARY KEY 删除外键 1alter table [数据库名.]表名称 DROP FOREIGN KEY 外键 关注知识追寻者：","path":"2020/11/11/数据库/MYSQL表结构操作-第七讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL数据类型(第六讲)","text":"一 前言每个数据库的数据类型从来都不是一个简单的数据结构，特别是使用不同的数据库，不同的引擎，其支持的数据类型也不一样，选择那种数据类型作为字段类型对数据库的性能也是天差地别，故对数据类型有个全面的认知，在数据库表设计的时候选择合适的数据类型就尤其重要；本篇是基于mysql的InnoDB的数据类型知识，要学就学主流知识； 学习本篇的基础是知识追寻者发过的SQL系列文章（公众号读者直接在专栏里面找即可） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 《SQL-SQL事物操作》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 基础数据类型2.1 字符串类型 char(n) 类型 ， 定长字符串，即储存的每个值占用的空间都一样； 适用于储存长度都一样的字段，比如 电话号码，身份证号，密码等；mysql 在 储存char类型字段时，会自动删除末尾保留的空格；如果是SQL SERVER 其后面就会保留空白字符；其最多储存 0 - 255 个字符，即8位； varchar(n) 类型, 变长字符串， 比如varchar(n)表示可以储存n个字节； 当字符串长度小于等于255个字节时，其会使用 n 个字节储存数据，额外一个字节记录n值，比如varchar(200), 其实际为 varchar(201)； 如果字符串长度大于255个字节，其会用2个字节记录n值，比如 varchar(500) ， 其实际为varchar(502)；其最多储存 0-65535 字节，即64位；由于其是可变长度，故在更新的时候，性能开销比较大； TEXT 长文本类型，存储大数据，其有一定的字符集和排序规则，故如果设置位text类型，性能会降低很多，占用的磁盘空间较大；其长度为0-65535 字节；其衍生的数据类型还有 TINYTEXT (0-255字节), MEDIUMTEXT (0-16 777 215 字节)，LONGTEXT 0-4 294 967 295字节）; blog 类型 ， 储存没有规则的二进制字符串，其存储 （0-65 535） 个字节；其衍生的类型有 TINYBLOB (0-255字节), MEDIUMBLOB(0-16 777 215 字节)， LONGBLOB（0-4 294 967 295字节）; 实际开发中 一般会选择 char ， varchar 类型进行储存数据，text少用，blog慎用，坑比较大；并且指定不同的数据类型长度也直接影响到数据库的性能，每次跟磁盘进行一次I/O的能力也不一样； 2.2 整型 tinyint 1字节 8 位 smallint 2字节 16位 mediumint 3字节 24 位 int 4字节 32位 bigint 8字节 64 位 其储存大小为 -2^（N-1）至 2^（N-1）-1 ，其中 N 为位数， 如果是无符号整型，则从0开似乎，没有负数，但其实际储存情况和有符号整型性能差不多，在实际开发中应该根据不同的业务需求，选择合适的类型； 常用tinyint(1)表示布尔型，1 为真，0为假； 2.3 浮点型 float(单精度) 4字节 double(双精度) 8字节 decimal, 其能指定储存精度，decimal(M,D) , 其中M代表总位数，D代表小数位，M-D 代表整数位；比如金钱相关的计算就推荐使用decimal ， 否则造成精度丢失问题，去面试的时候如果问道使用浮点型就回家等通知吧！ 2.4 日期时间类型 date , 日期 通常就是 YYYY-MM-DD 格式, 当然也可以格式化为其它格式，所有的格式化形式都不在本篇讨论范围内； time, 时间 格式 hh:mm:ss ； year 年份 YYYY;不建议使用YY datetime , 日期时间格式 ， 其日期范围 为 1001 至 9999 年，精度为秒；占用8位； timestamp, 挺多人称其为时间戳，其实其是与Unix时间戳相同而已，从 1970 1 月 1日 午夜来表示秒数，最多储存至2038 年。 其依赖于时区，占用4位； 在日常开发中推荐使用 timestamp 进行储存时间，性能相比于datetime 较好；它们的标准格式都为 YY-MM-DD hh:mm:ss； 2.5 枚举与SET类型 enum(val1, val2, val3…)， 用于储存固定值，比如性别男女， 四级 春夏秋冬；其内部使用整型排序，显示时使用字符串，故在排序的时候可能会发生一些奇怪的现象，可以用field进行指定排序; 储存大小为16位； 示例 123create table test_enum ( `gender` enum(&#x27;男&#x27;, &#x27;女&#x27;) );INSERT INTO `zszxz`.`test_enum`(`gender`) VALUES (&#x27;男&#x27;); set(val1, val2, val3…), 集合, 类似于数组，相比于枚举只能存储单个值，其能储存多个值；储存大小为64位； 示例 123create table test_set ( `gender` set(&#x27;男&#x27;, &#x27;女&#x27;) );INSERT INTO `zszxz`.`test_set`(`gender`) VALUES (&#x27;男,女&#x27;); 2.6 其它其它数据类型比如 ,bit , 储存位， 坑也很大；不建议使用；在众多数据类型中优先选择整型，其性能相比于字符串的排序规则等会快很多；字段的修饰符 通常有 NULL , NOT NULL , CONMENT 等， 如果是非空字段尽量默认为NOT NULL , 其能带来一定性能提升，并且在使用索引的时候相对简单；尽量不要使用外键，每次外键都会带来额外的性能开销； 关注知识追寻者：","path":"2020/11/11/数据库/MYSQL数据类型-第六讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL事物(第五讲)","text":"一 前言本篇内容是关于SQL事物知识，主要包括事物的概念，ACID，幻读，不可重复度，脏度等内容； 学习本篇的基础是知识追寻者发过的SQL系列文章（公众号读者直接在专栏里面找即可） 《SQL-你真的了解什么SQL么？》 《SQL-小白最佳入门sql查询一》 《SQL-小白最佳入门sql查询二》 《SQL- 多年开发人员都不懂的插入与更新删除操作注意点》 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 事物的概念事物意指一组原子性的的SQL操作，即保证一组 SQL 语句要么全部执行，要么全部不执行； 一个经典的案例银行转账: 小知转账100元给小识，操作步骤如下 银行查询小知账号金额大于等于100 银行从小知账号扣除100元 银行将小识账号金额增加100元 假设 有张金额表 money,对应SQL语句如下 begin; select balance from money where username = ‘xiaozhi’ and balance &gt; = ‘100’; update money set balance = balance - 100 where username = ‘xiaozhi’; update money set balance = balance + 100 where username = ‘xiaoshi’; commit; 如上语句就是 一次原子性操作，begin 为开启事物， commit为提交事物；假设没有begin 和 commit ，在执行语句3的时候发生了断电，小知的账号金额扣除了100，但小识的金额却没有加上100，这就造成了数据的不一致，故事物在SQL中占有主导性地位，特别是关于金额类操作；学习事物必须满足4个条件(ACID), 原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 三 ACID3.1 原子性原子性的概念比较简单，就是事物被当初一个最小的单位，其不可分割，并且整个事物中的操作要么全部失败，要么全部成功； 3.2 一致性一致性 的意思就是 数据从一种状态转移至另一种状态，其数据完整没有被破坏；如上例子小知扣除100元后，小识账号金额没有增加100，这就是状态转移后破坏了数据的一致性； 3.3 隔离性隔离性是指，一个事物在做出修改后至到事物提交前，其它的事物是不可见的；如上例子小知账号有500元 扣除100元后， 假设有另外一个事物参与进来，其是不能看见小知账号为400元，应该是500元； 3.4 持久性持久性的概念更加简单，即一旦事物提交，则数据修改操作永久保存到数据库中；如果服务器发生故障则不会对持久化的数据产生任何影响； 四 事物的简单操作4.1 事物语句 bengin 或者 start transction 表示开启事物； commit也可以使用 commit work 表示提交事物，提交事物后数据就持久化了； rollback 也可以使用 rollback work 表示回滚事物，即我后悔刚刚的SQL操作，一切不算数； savepoint identifier，savepoint 允许在事务中创建一个保存点，一个事务中可以有多个 savepoint ； release savepoint identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； rollback to identifier 事务回滚到保存点； set transction 用来设置事务的隔离级别; mysql 中 常用 的就是 begin commit rollback 三个语句； 4.2 事物的隔离级别事物的隔离级别在每种数据库的存储引擎中都不一样，一般是提交读，但mysql使用InnoDB 时 是可重复度； 读未提交（read uncommited） 即事物修改后语句后并没有提交，其修改的内容对其它事物是可见的，此时就会出现脏读，如上例子 小知账号500扣除 100 元 ，被其它事物读看见读取了400元，就出现了脏度；所以读未提交在实际生产环境中基本不会使用到 读已提交 （read commited） 即一个事物只能读取到另一个事物已经提交后的数据；如上例子假设小知账号金额500元， 小知账号金额扣除100，小识账号金额 加100，事物提交后，另一个事物读取小知账号金额400； 可重复读 （repeatable read）即同一个事物多次读取的数据前后一致；如上例子，小知账号500元，当执行如上操作事物完成后，另一个事物读取n次小知的账号都是400元； 可串行化 （serializable）即在每行的数据上都加上一行读锁，会导致锁竞争问题，数据库性能会降低；事物的最高级别；实际生产环境中也很少用到； mysql 中可以使用 set transction 来设置 事物的隔离级别 即（read-uncommitted、read-committed、repeatable-read 和 serializable） 12345678-- mysql 5版本select @@tx_isolation;set tx_isolation = &#x27;read-uncommitted&#x27;;-- mysql 8版本 select @@transaction_isolation;set transaction_isolation = &#x27;&#x27;; 4.3 事物并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读：A将数据库中的数据进行修改，但是B就在这个时候插入了一条数据，当A改完后发现还有一条记录没有改过来，这就叫幻读。所以幻读针对插入语句； mysql 的 InnoDB 通过 多版本并发控制 (MVCC) 解决了幻读问题； 4.3 实际操作一张顾客表，建表语句如下 12345678CREATE TABLE `customer` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `customer_name` varchar(255) DEFAULT NULL COMMENT &#x27;顾客名称&#x27;, `gender` varchar(255) DEFAULT NULL COMMENT &#x27;性别&#x27;, `telephone` varchar(255) DEFAULT NULL COMMENT &#x27;电话号码&#x27;, `register_time` timestamp NULL DEFAULT NULL COMMENT &#x27;注册时间&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=&#x27;顾客表&#x27;; 提交事物示例 123begin;INSERT INTO `zszxz`.`customer`(`customer_name`, `gender`, `telephone`, `register_time`) VALUES (&#x27;知识追寻者&#x27;, &#x27;男&#x27;, &#x27;9991&#x27;, NULL);commit; 此时 数据库中会增加一条数据； 回滚示例 123begin;INSERT INTO `zszxz`.`customer`(`customer_name`, `gender`, `telephone`, `register_time`) VALUES (&#x27;知识追寻者&#x27;, &#x27;男&#x27;, &#x27;9991&#x27;, NULL);rollback; 此时数据中并没有添加新数据 4.3 mysql 事物的自动提交实际上Mysql 中每次的事物操作默认都是自动提交(AUTOCOMMIT) , 即每条语句操作都会自动提交； 读者可以使用 如下 语句查看 mysql 的 AUTOCOMMIT 是否 开启 1SHOW VARIABLES LIKE &#x27;AUTOCOMMIT&#x27; 操作示例如下： 使用如下语句可以对 自动提交进行设置 SET AUTOCOMMIT=0 （0 或者OFF 表示禁止自动提交） SET AUTOCOMMIT=1 （1或者ON开启自动提交） 关注知识追寻者：","path":"2020/11/11/数据库/MYSQL事物-第五讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL插入与更新删除(第四讲)","text":"一 前言经过之前的 【SQL】-SQL介绍， 【SQL】- SQL检索阶段一， 【SQL】-sql检索阶段二 的三篇文章你已经学会的sql的相关概念和如何查询数据库，这篇文章主要后续对数据库表的进入插入，更新，和删除操作，那么你学完这篇就等于最基础的sql开发你已经学完了，如果跟java结合起来也就是crud；后续会推出sql的进阶学习文章，当然出文章的速度不是很快，原因是还有其他类型文章要出； 建表语句： 1234567891011121314151617181920CREATE TABLE &#96;user&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;用户id&#39;, &#96;name&#96; varchar(255) DEFAULT NULL COMMENT &#39;用户名&#39;, &#96;telephone&#96; varchar(255) DEFAULT NULL COMMENT &#39;用户电话&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8;CREATE TABLE &#96;student&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;name&#96; varchar(255) DEFAULT NULL, &#96;age&#96; int(11) DEFAULT NULL, &#96;info&#96; varchar(255) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;5 DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (1, &#39;youku1&#39;, 18, &#39;大一新生&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (2, &#39;youku2&#39;, 23, &#39;毕业生&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (3, &#39;jeff&#39;, 25, &#39;社会人士&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (4, &#39;smile&#39;, 17, &#39;高三学子&#39;); 二 插入插入数据库记录也就是使用 INSERT 关键字，能将一条语句插入数据库，高级的可以组合 SELECT 关键字 实现 插入查询的结果集，插入整张表； 2.1 插入一条完整数据语句示例： 1INSERT INTO &#96;user&#96; ( id, &#96;name&#96;, telephone) VALUES (&#39;2&#39;,&#39;zszxz&#39;,&#39;1327&#39;); 语句结果： 12 zszxz 1327 语句分析： 插入 数据 到 user 表 字段分别是 id, name , telephone; 值 分别是 2 , zszxz , 1327; 这是插一条完整的语句，虽然INTO可以忽略不写，但不建议这么做，原因是在数据库管理系统间会出现移植性问题；还有字段也可以忽略不写，但也不建议这么做，这容易造成插入数据出错；字段的位置和值的位置是一 一对应；如果有的位置没值可以使用NULL代替； 2.2 插入部分数据语句示例： 1INSERT INTO &#96;user&#96; ( id, &#96;name&#96;) VALUES (&#39;3&#39;,&#39;zszxz&#39;); 语句结果： 13 zszxz 语句分析： 插入数据到user表，字段分别是 id , name ; 值分别是，3，zszxz; 可以看见我们没有插入telephone字段； 2.3 插入检索数据插入检索的数据也就是能将查询的结果插入进另一张表；我们可以使用 INSERT SELECT 关键组合成一条语句实现； 语句示例： 12INSERT INTO &#96;user&#96; ( id, &#96;name&#96;) SELECT id, &#96;name&#96; FROM student WHERE id &#x3D; &#39;4&#39;; 语句结果： 14 smile 语句分析： 插入数据到 user 表， 字段分别是 id, name ,值是查询字段 id ,name 来自 student 表，条件是 id 等于 4；可以看见我们插入数据的列根查询的列名称是匹配对应的，其实只要列顺序一致即可，不过为了不出错，建议使用名称匹配； 2.4 复制表复制表即，检索一张表的数据全部插入另一张表；有两种方法，但是不同的数据库管理系统支持不同，具体的看下文； 语句示例： 1SELECT id , &#96;name&#96; INTO student_copy FROM student; 语句分析 查询字段 id, name 插入 student_copy 表，来自 student 表； 注意 这条语句会帮我们自动创建表 student_copy，由于作者使用的是mysql做演示，这条sql执行失败，原因是其不支持这种方式；如果是想复制整张表可以使用通配符 * ； 语句示例： 12CREATE TABLE student_copy AS SELECT * FROM student; 语句结果： 12341 youku1 18 大一新生2 youku2 23 毕业生3 jeff 25 社会人士4 smile 17 高三学子 语句分析： 创建表 student_copy 数据结构来源 查询 所有字段来自 student 表； 三 更新更新数据库的行使用 UPDATE 关键字；更新操作是个很危险的操作，在每次执行前都应该检查是否丢了 where 子句； 3.1 更新所有行语句示例： 1UPDATE student_copy set age &#x3D; Null; 语句结果： 12341 youku1 大一新生2 youku2 毕业生3 jeff 社会人士4 smile 高三学子 语句分析： 更新 student_copy 表， 设置 字段 age 值为null； 可以看见表中所有的学生年龄都是Null; 如果有多个字段需要更新，使用 逗号隔开； 3.2 更新特定的行语句示例： 1UPDATE student_copy set age &#x3D; &#39;18&#39; WHERE id &#x3D; &#39;4&#39;; 语句结果： 14 smile 18 高三学子 语句分析： 更新 student_copy 设置 学生的年龄是 18 条件是 id 等于 4； 3.3 更新来自查询的结果集语句示例： 123UPDATE student_copy set age&#x3D; student.age, name &#x3D; student.nameFROM studentWHERE student.id &#x3D; student_copy.id; 语句分析： 更新 student_copy 表 设置 age 是 student 表的 age，name 是 student 表的 name 条件是 student 的id 等于 student_copy 表的 id; 遗憾的是 mysql 数据库管理系统又执行失败了，其不支持这种方法更新，如果是postgresql就支持，其他数据库应查阅官方文档查看是否支持这种方式更新； 语句示例： 12UPDATE student_copy INNER JOIN student on student.id &#x3D; student_copy.id SET student_copy.age&#x3D; student.age, student_copy.name &#x3D; student.name; 语句结果： 12341 youku1 18 大一新生2 youku2 23 毕业生3 jeff 25 社会人士4 smile 17 高三学子 语句分析更新 student_copy 关联 student 条件 是 student 的 id 等于 student_copy 表的id ; 设置 student_copy 表的 age 等于 student 的 age ; 设置 student_copy 表的 name 等于 student 的 name ；这才是正确进入Mysql 的更新查询姿势； 四 删除表删除表中的行可以使用 DELETE 关键字 ，可以删除特定的行或者全部；使用时请先看是否丢了where子句； 4.1 删除整张表数据1DELETE from student_copy; 语句分析 删除 全部行 来自 student_copy 表； 4.2 删除特定的行语句示例： 1DELETE from student WHERE id &#x3D; &#39;4&#39;; 语句分析： 删除 行 来自 student 表条件时 id 等于 4； 五 更新和删除的建议 每次进行操作前检查是否丢失 where 子句； 每次操作前最好先使用 select 语句验证；","path":"2020/11/11/数据库/MYSQL插入与更新删除-第四讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL检索2(第三讲)","text":"# 一 前提准备 先声明一下，下面的库表只是简易的学习示例，不是生产的设计，不要深究，此文我们的目的是学习sql的检索不是库表设计；初学者最好跟着作者的文章一步一步敲一遍，如果没有使用过sql的可以查阅作者SQL系列专栏； 1.1 顾客表12345678910CREATE TABLE &#96;customer&#96; ( &#96;userId&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;顾客id&#39;, &#96;userName&#96; varchar(255) DEFAULT NULL COMMENT &#39;顾客名称&#39;, &#96;telephone&#96; varchar(255) DEFAULT NULL COMMENT &#39;顾客电话&#39;, PRIMARY KEY (&#96;userId&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;springboot&#96;.&#96;customer&#96;(&#96;userId&#96;, &#96;userName&#96;, &#96;telephone&#96;) VALUES (1, &#39;zxzxz&#39;, &#39;1327&#39;);INSERT INTO &#96;springboot&#96;.&#96;customer&#96;(&#96;userId&#96;, &#96;userName&#96;, &#96;telephone&#96;) VALUES (2, &#39;youku1327&#39;, &#39;1996&#39;); 1.2 商品表1234567891011CREATE TABLE &#96;product&#96; ( &#96;productId&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;产品id&#39;, &#96;productName&#96; varchar(255) DEFAULT NULL COMMENT &#39;产品名称&#39;, &#96;price&#96; varchar(255) DEFAULT NULL COMMENT &#39;产品价格&#39;, PRIMARY KEY (&#96;productId&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;springboot&#96;.&#96;product&#96;(&#96;productId&#96;, &#96;productName&#96;, &#96;price&#96;) VALUES (1, &#39;苹果&#39;, &#39;5&#39;);INSERT INTO &#96;springboot&#96;.&#96;product&#96;(&#96;productId&#96;, &#96;productName&#96;, &#96;price&#96;) VALUES (2, &#39;梨&#39;, &#39;4&#39;);INSERT INTO &#96;springboot&#96;.&#96;product&#96;(&#96;productId&#96;, &#96;productName&#96;, &#96;price&#96;) VALUES (3, &#39;香蕉&#39;, &#39;3&#39;); 1.3 订单表123456789101112CREATE TABLE &#96;order&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;, &#96;userId&#96; int(11) DEFAULT NULL COMMENT &#39;客户id&#39;, &#96;productId&#96; int(11) DEFAULT NULL COMMENT &#39;产品id&#39;, &#96;orderName&#96; varchar(255) DEFAULT NULL COMMENT &#39;订单名称&#39;, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8;INSERT INTO &#96;springboot&#96;.&#96;order&#96;(&#96;id&#96;, &#96;userId&#96;, &#96;productId&#96;, &#96;orderName&#96;) VALUES (1, 1, 1, &#39;乖乖订单&#39;);INSERT INTO &#96;springboot&#96;.&#96;order&#96;(&#96;id&#96;, &#96;userId&#96;, &#96;productId&#96;, &#96;orderName&#96;) VALUES (2, 2, 2, &#39;悦悦订单&#39;);INSERT INTO &#96;springboot&#96;.&#96;order&#96;(&#96;id&#96;, &#96;userId&#96;, &#96;productId&#96;, &#96;orderName&#96;) VALUES (3, 1, 3, &#39;香香订单&#39;); 二 聚集函数的使用聚集函数的定义就是讲一些行的数据运行某些函数，返回一个期望值；下面讲述的是开发中经常使用到的聚集函数； 2.1 avg()avg函数也就是计算行的数量，通过计算这些行的特定列值和，计算出平均值(特定列值之和/行数=平均值)；使用时注意其会忽略列值为NULL的行； 语句示例： 12SELECT AVG(price) FROM product; 语句结果： 14 语句分析：查询价格平均值来自商品表（5+4+3）/3=4； 2.2 count()count函数用于计算行数，其中count(*)计算所有行的数目，count(“column”)会忽略column为NULL的行数； 语句示例： 12SELECT count(*) FROM product; 语句结果： 13 语句分析： 查询总行数来自商品表； 2.3 max()max函数返回特定列值的最大值；忽略特定列为NULL的行； 语句示例： 12SELECT max(price) FROM product; 语句结果： 15 语句分析： 查询价格的最大值来自商品表； 2.4 min()返回特定列的最小值；忽略特定列为NULL的行； 语句示例： 12SELECT min(price) FROM product; 语句结果： 13 语句分析： 查询价格的最小值来自商品表； 2.5 sum()返回特定列的和；忽略特定列为NULL的行； 语句示例： 12SELECT sum(price) FROM product; 语句结果： 112 语句分析： 查询价格的总和来自商品表； 三 分组数据分组定义就是按照特定的列进行分组查询，使用 GROUP BY 子句进行分组查询；注意点：SELEC后面的列必须出现在group by 子句后面，否则报语法错误；通常 group by 子句的位置是where 条件之后，order by 子句之前； 3.1 分组求和语句示例： 12SELECT sum(price) FROM product GROUP BY productName; 语句结果： 123453 语句分析： 先根据商品名称分为三组 苹果 ，梨 ， 香蕉 ；再根据不同的分组求和，因为我们表中的数据只有这三条所以就是每行的值； 3.2 分组过滤语句示例： 12SELECT count(*) FROM &#96;order&#96; GROUP BY userId HAVING count(*) &gt; 1; 语句结果： 12 语句分析 查询 条数来自 订单表 根据客户id分组，过滤条件 条数大于2；注意 having 与 where其实差别不大，通常我们讲where当作标准的过滤条件，having用作分组过滤条件；注意有的数据库管理系统having不支持别名作为分组过滤条件中的一部分； 3.3 分组排序语句示例： 12SELECT count(*) as count FROM &#96;order&#96; GROUP BY userId ORDER BY count; 语句结果： 1212 语句分析查询 行数 来自 订单表 根据 客户id分组，根据 行数排序；注意点是经过分组后结果看似经过排序，其实并不能确保是排序后的结果，所以要排序一定要使用order by子句； 四 子查询子查询的定义是在查询中嵌套查询；注意子查询只能返回单列，若企图返回多列会报语法错误； 语句示例： 123456SELECT userName FROM customer WHERE userId &#x3D; ( SELECT userId FROM &#96;order&#96; WHERE orderName &#x3D; &#39;乖乖订单&#39; ) 语句结果： 1zxzxz 语句分析： 是执行语句 【SELECT userId FROM order WHERE orderName = ‘乖乖订单’ 】得到结果 userId = ‘1’ ;然后执行语句 【 SELECT userName FROM customer WHERE userId = ‘1’】； 五 联结表联结表也就是我们通常意义上的关联表查询，主要功能是能在多表中使用一条sql检索出期望值，但实际库表中是存在的，只在查询期间存在；其主要分为内联结和外连接使用的 join 关键字；联结表会返回一对多，一对一，多对多关系；联结表不建议超过三张表以上； 5.1 简单联结语句示例： 12345678SELECT userName, orderName FROM customer, &#96;order&#96; WHERE customer.userId &#x3D; &#96;order&#96;.userId; 语句结果： 123zxzxz 乖乖订单youku1327 悦悦订单zxzxz 香香订单 语句分析 ： 查询 用户名来自用户表，查询订单名称来自订单表，根据 订单表的客户id 等于 客户表的客户id做为联结条件；也就是说会查询出两张表根据userId为等值条件的 userName 和 orderName 的 数据; 注意点 ： 简单联结中where子句后面 必须 要带上 两张表的联结关系，否则会出现笛卡尔集（比如3行数据联结另一张表3行数据会产生3*3=9条） 5.2 内联结内连接（inner join） 又称等值联结，其查询结果跟之前的简单联结一致； 语句示例： 123456SELECT userName, orderName FROM customer INNER JOIN &#96;order&#96; ON ( customer.userId &#x3D; &#96;order&#96;.userId ); 语句结果： 123zxzxz 乖乖订单youku1327 悦悦订单zxzxz 香香订单 语句分析： 跟之前的简单联结稍微不同的是 等值条件 是放在 on 关键字后面，在等值条件后面还可以进行 where 子句过滤条件查询； 5.3 自然联结自然联结与标准的联结不同就是只返回值唯一的列，不会返回重复的列； 自然联结示例： 123456SELECT userName, orderName FROM customer INNER JOIN &#96;order&#96; ON ( customer.userId &#x3D; &#96;order&#96;.userId ); 自然联结结果 123zxzxz 乖乖订单youku1327 悦悦订单zxzxz 香香订单 非自然联结示例： 12345SELECT * FROM customer INNER JOIN &#96;order&#96; ON ( customer.userId &#x3D; &#96;order&#96;.userId ); 非自然联结结果： 1231 zxzxz 1327 1 1 1 乖乖订单2 youku1327 1996 2 2 2 悦悦订单1 zxzxz 1327 3 1 3 香香订单 重复列是 userId; 5.4 外联结右外联结 语句示例： 12345SELECT * FROM &#96;order&#96; RIGHT OUTER JOIN customer ON ( customer.userId &#x3D; &#96;order&#96;.userId ); 右外联结是指 相对于 OUTER JOIN 右边的表，那么这会查询出右边表的所有数据 和根据等值条件匹配左边表的数据，如果左边表的数据不匹配，那么其返回列的值是NULL充当； 左外联结 语句示例： 12345SELECT * FROM customer LEFT OUTER JOIN &#96;order&#96; ON ( customer.userId &#x3D; &#96;order&#96;.userId ); 左外联结是指 相对于 OUTER JOIN 左边的表，那么这会查询出左边表的所有数据 和根据等值条件匹配右边表的数据，如果右边表的数据不匹配，那么其返回列的值是NULL充当； 区别： 左外联结和右外联结其实没什么不同，只是查询表顺序不一致，我们通过置换 表的相对位置就可以查询出一样的结果； 六 组合查询组合查询是指可以执行多条SELECT 语句，其查询的结构是一致的，返回查询结果，通常我们称为复合操作或者并(union) 语句示例： 12345678SELECT userId FROM customer UNIONSELECT userId FROM &#96;order&#96; 返回结果： 1212 语句分析： union 关联的字段或者聚合函数在两张表中必须是相同的，其默认会讲结果进行去重处理；如果不去重可以使用 union all 语句示例： 12345678SELECT userId FROM customer UNION ALLSELECT userId FROM &#96;order&#96; 执行结果： 1234512121 语句分析：等同于讲客户表和订单表的用户id都合并为一个并集查询出来，而且不去重；如果对组合语句进行排序，默认是会作用于组合后的数据字段排序，而不是作用于其中的一条查询语句； 七 结束语到本文看完，基本的查询语句都已经学会了，后面就是插入，更新，删除，相对于查询比较简单，有空后续会写相关文章；","path":"2020/11/11/数据库/MYSQL检索2-第三讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL检索1(第二讲)","text":"# 一 说明 如果是初学者，建议去网上寻找安装Mysql的文章安装，以及使用navicat连接数据库，以后的示例基本是使用mysql数据库管理系统； 二 准备前提需要建立一张学生表，列分别是id，名称，年龄，学生信息；本示例中文章篇幅原因SQL注释略； 建表语句： 1234567CREATE TABLE &#96;student&#96; ( &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, &#96;name&#96; varchar(255) DEFAULT NULL, &#96;age&#96; int(11) DEFAULT NULL, &#96;info&#96; varchar(255) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8; 表中的数据： 12345INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (1, &#39;youku1&#39;, 18, &#39;大一新生&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (2, &#39;youku2&#39;, 23, &#39;毕业生&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (3, &#39;jeff&#39;, 25, &#39;社会人士&#39;);INSERT INTO &#96;springboot&#96;.&#96;student&#96;(&#96;id&#96;, &#96;name&#96;, &#96;age&#96;, &#96;info&#96;) VALUES (4, &#39;smile&#39;, 17, &#39;高三学子&#39;); 三 基本检索3.1 select 关键字sql 都是由许多关键字（keyword）组成的语句，关键字是数据库的保留字，用户不能将其当作建表的表名，字段等；表中的数据检索使用select关键字作为开头进行查询数据库表的信息； 3.2 检索单个字段语句示例： 1SELECT name FROM student 查询结果： 1234youku1youku2jeffsmile 语句分析： select 是 查询 的意思 ， name 代表表中的字段 ，from 表示来自哪张表，其后面的student就是表；连起来的意思就是查询字段是name的数据来自表student； 3.3 sql语句注意点多sql语句一起执行使用封号（;）隔开，在拼写语句时表的关键字都建议使用大写，表的字段和表名使用小写；为了容易阅读建议将sql分成多行（由于文章篇幅原因就不分了）；sql语言也是使用英文字母，不要开中文，以免造成符号错误不容易发现；sql语句默认不区分大小写； 3.4 检索多个字段语句示例： 1SELECT name,age FROM student; 语句结果： 1234youku1 18youku2 23jeff 25smile 17 语句分析： 查询字段 名字，年龄来自表student；多个列检索时使用逗号（,）隔开； 3.5 检索所有字段语句示例： 1SELECT * FROM student; 语句结果： 12341 youku1 18 大一新生2 youku2 23 毕业生3 jeff 25 社会人士4 smile 17 高三学子 语句分析： 通配符 （*）表示返回表中的所有列，如果不是必须建议不要使用通配符，会影响数据库性能； 3.6 distinctdistinct 表示区分，意指检索出来的行是唯一（去重），其放在列的最前面；如果使用了关键字distinct，其作用于后面的所有列（由于本示例数据没有重复示例，结果就不是很清晰）； 1SELECT DISTINCT name, age FROM student; 语句结果： 1234youku1 18youku2 23jeff 25smile 17 3.7 限制条数access 和 sql server ： 1SELECT TOP 2 name FROM student TOP 2 表示限制返回前2行 postgresql 、SQLite和 mysql： 1SELECT name FROM student LIMIT 2; limit 2 表示限制返回前2行； DB2： 1SELECT name FROM student FETCH FIRST 2 ROWS ONLY FETCH FIRST 2 ROWS ONLY 表示只抓取前2行数据 语句结果： 12youku1youku2 3.8偏移示例： 1SELECT name FROM student LIMIT 1 OFFSET 1; 语句分析 表示查询列名称来自学生表 限制条数1，偏移值1；意思就是查询学生表中的第二行数据；offset表示跳跃或者偏移； mysql和MariaDB简化形式: 1SELECT name FROM student LIMIT 1,2; 表示查询字段名称来自学生表，限制2条，偏移1条；注意顺序； 语句结果： 12youku2jeff 四 排序检索4.1 ORDER BY 子句示例： 1SELECT name,age FROM student ORDER BY age 语句分析； 检索字段名称，年龄来自学生表按照列年龄排序；注意默认是升序，ORDER BY 子句通常在语句末尾； 语句结果： 1234smile 17youku1 18youku2 23jeff 25 4.2 多列排序示例： 1SELECT name,age FROM student ORDER BY age DESC, name ASC; 语句分析： 查询名称，年龄来自学生表，按照年龄降序，名称升序进行排序；关键字 DESC(descending) 意指降序，字母默认Z-A; ASC（ascending）意指升序，字母默认A-Z；多列情况下，每个列后面指定使用DESC，使用逗号（,）隔开，如果不写，默认升序； 语句结果： 1234jeff 25youku2 23youku1 18smile 17 4.3 按位排序语句示例： 12SELECT name,age FROM student ORDER BY 2 DESC, 1 ASC; 按位指查询字段的位置，2 对应字段age,1对应字段name；结果和4.2一致； 五 过滤检索sql 语句中过滤条件（filter condition）的关键字是 WHERE，其使用方式是跟在表名之后； 5.1 WHERE语句操作符根据不同的数据库管理系统，其支持的操作符略有不同，所以下文较多重复意思的操作符，应查阅官方文档说明，哪些操作符是支持使用的数据库管理系统； 操作符 说明 = 等于 &gt; 大于 &lt; 小于 != 不等于 &lt;&gt; 不等于 &gt;= 大于等于 &lt;= 小于等于 !&lt; 不小于 !&gt; 不大于 BETWEEN 在中间 IS NULL 为空 5.2 单条件过滤示例： 12SELECT * FROM student WHERE name &#x3D; &#39;jeff&#39;; 语句分析; 查询所有字段来自学生表 条件是 学生名称是 jeff；注意 非表字段，表名，关键字，使用2个单引号（’’）括起来，里面存放的是我们输入的数据； 语句结果; 13 jeff 25 社会人士 5.3 多条件过滤多条件过滤时使用 AND 或者 OR 子句；AND连接表达式表示过滤条件都为真的数据；OR连接表达式表示匹配过滤条件任意一个； AND示例： 12SELECT * FROM student WHERE age &gt;&#x3D; &#39;18&#39; AND age &lt;&#x3D; &#39;23&#39;; 语句分析： 查询所有字段来自学生表，条件是 学生年龄大于等于18 并且 学生年龄小于 23； 语句结果： 121 youku1 18 大一新生2 youku2 23 毕业生 OR示例： 12SELECT * FROM student WHERE age &gt;&#x3D; &#39;18&#39; OR age &lt;&#x3D; &#39;23&#39;; 语句分析： 检索所有字段来自学生表，条件是 学生年龄大于等于18，或者学生年龄小于23； OR 和 AND 示例： 12SELECT * FROM student WHERE age &gt;&#x3D; &#39;18&#39; AND (age &lt;&#x3D; &#39;23&#39; OR id &gt;&#x3D;2); 语句分析： 在使用OR 和 AND 的时候应该明确过滤条件，然后使用小括号括起来，由于数据库管理系统是根据顺序执行，如果不使用小括号很容易造成语义错误；查询所有字段来自学生表 过滤条件 年龄大于 18 并且 （年龄小于23 或者 id 大于2）的数据； 5.4 范围查询示例： 12SELECT * FROM student WHERE age BETWEEN &#39;18&#39; And &#39;23&#39;; 语句分析 BETWEEN 表示范围查询，查询所有字段来自学生表，过滤条件学生年龄在18至23之间； 语句结果： 121 youku1 18 大一新生2 youku2 23 毕业生 5.5 空值查询示例： 12SELECT * FROM student WHERE age IS NULL; 语句分析： 查询所有字段来自学生表，过滤条件 学生年龄 为空；数据库表不填充数据默认为空（NULL），当然你也可以给指定类型的列设置默认值； 5.6 IN 操作示例： 12SELECT * FROM student WHERE age IN (18,23,25); 语句分析： 查询所有字段来自学生表 ，过滤条件 年龄 是 18 或者 23 或者 25 ；IN是个范围查询，匹配小括号中指定的任意值，其功能跟OR类似，一个IN 就相当于好多个OR； 语句结果： 1231 youku1 18 大一新生2 youku2 23 毕业生3 jeff 25 社会人士 5.7 NOT 操作符示例： 12SELECT * FROM student WHERE NOT age&#x3D;&#39;25&#39;; 语句分析： NOT 操作符表是否定；其跟在WHERE后面功能类似&lt;&gt;; 六 通配符检索6.1 通配符的介绍通配符是组成匹配模式的特殊字符串；如果有用过正则表达式的同学肯定不陌生，这个与其类似；检索文本的通配符是用在关键词Like 后面； 6.2 通配符 %示例： 12SELECT * FROM student WHERE name LIKE &#39;you%&#39; ; 语句分析： 查询所有字段来自学生表，过滤条件 名字匹配以you开头的字符串后面匹配任意个任意字符；%通配符代表任意个任意字符串,0也算在内，但不包括null； 语句结果： 121 youku1 18 大一新生2 youku2 23 毕业生 示例： 12SELECT * FROM student WHERE name LIKE &#39;%i%&#39; ; 语句分析： 查询所有列来自学生表，过滤条件学生的名称匹配中间必须出现一次字母i，字母i的前后可以匹配任意个任意字符串； 语句结果; 14 smile 17 高三学子 6.3 通配符 _通配符 _ 代表匹配一个字符串；在Access数据库中不是 _ 而是 ?； 示例： 12SELECT * FROM student WHERE name LIKE &#39;youku_&#39; ; 语句分析： 查询所有列来自学生表，过滤条件 学生名称 匹配模式 youku 后面一个为任意字符串； 语句结果; 121 youku1 18 大一新生2 youku2 23 毕业生 6.4 通配符 []通配符 [] 表示匹配指定一个位置一个字符；其里面可以存放多个字符，关系是or，模式匹配时只占用一个位置，Access,SQL SERVER 支持； 七 字段基本操作7.1 字段拼接示例： 12SELECT concat(&#39;你好啊&#39;,name,&#39;327今天心情怎么样&#39;) FROM student WHERE id &#x3D; &#39;1&#39; ; 语句分析： 函数 concat 就是将多个字符子串拼接成一个字符串；不同的数据库管理系统其使用的方式略有差别，应查阅官方文档；在 mysql 中使用 concat函数；在postgresql中使用 || ； 在 Access和 sql server中使用 +; 语句结果： 1你好啊youku1327今天心情怎么样 7.2 去除空白字符串语句示例： 12SELECT RTRIM(&#39; 哥，今天管饱 &#39;) FROM student WHERE id &#x3D; &#39;1&#39; ; 语句分析： RTRIM(STR) 函数是去掉右边的字符串；TRIM(STR)是去掉字符串两边的空白字符；LTRIM(STR)是去掉字符串左边的空白字符； 语句结果; 1哥，今天管饱 7.3 别名语句示例： 12SELECT name as student_name FROM student WHERE id &#x3D; &#39;1&#39; ; 语句分析： 别名（alias）是可以给字段，或者表起别名；当多表操作出现重复字段时使用别名是个很好的选择；别名可以使用AS关键字，虽然其是可省略，但平时我们最好加上它增强阅读性； 7.4 计算 操作符 说明 * 乘 + 加 - 减 / 除 语句示例： 12SELECT 2 * 8; 语句结果： 116 八 关于作者","path":"2020/11/11/数据库/MYSQL检索1-第二讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MYSQL数据库介绍(第一讲)","text":"# 一SQL 介绍 SQL（Structured Query Language）,语义是结构化语言， 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统； 二 数据库介绍2.1 数据库我们已经知道了SQL是操作数据库的语言，那么数据库是什么？数据库（database）是 保存一个文件或者一组文件的容器；这样说你可能还不懂，可以比喻为数据是一个图书馆，图书馆里面收藏有好多书，我们可以认为数据库就是能够存储数据的容器；其实数据库很常见，你每天都在操作数据库，比如你看手机，上网，微信聊天，其实背后都在操作数据库，只是展现操作数据库的形式不一样而已； 2.2 数据库管理系统数据库里面有好多的数据，就像图书管一样有好多的书，书是由图书管理员进行管理，那么什么东西能够管理数据库呢？没错就是数据库管理系统（Database Manage System），比如 mysql, Access、DB2、Informix、 Server、Oracle、Sybase以及其他数据库系统； 2.3 表表是一种结构化的文件可以用来存储特定类型的数据；这么说你可能没听懂，我们再举个例子，表就像图书馆里面的图书架子，每个书架都放了好多书；再不懂也没关系，你总用过excel吧，excel表格里面的标签页 （sheet） 我们就可类比数据表，表存放的就是特定类型的数据，跟excel的sheet一样；重点是每个表的表名是唯一，不可重复； 2.4 列和数据类型列是表中的一个字段，一个表由多个列组成；每个列都由特定的数据类型，只能存放指定数据类型的数据；听不懂没关系，我们类比excel，excel中的sheet也是由多个列组成，每个列都有指定的数据类型，比如文本，数字，日期类型；那数据库的表跟excel的结果是类似的； 数据类型就是限定表中的每个列只能存储特定类型的数据，常见的数据类型有整型，数字，文本，字符串，日期等等。 2.5 行行就是表中的一条记录，类比excel，很容易理解； 2.6 主键主键就是每行的唯一标识，其特性是主键，不能为空，不能重复，不能修改；主键我们可以类比身份证号，每个身份证号都是唯一不可重复的； 2.7 行号行号指表中每个行的行号；","path":"2020/11/11/数据库/MYSQL数据库介绍-第一讲/","date":"11-11","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"最好用的数据库文档生成工具","text":"一 前言本文介绍一些比较流行的数据库文档生成工具，什么是数据库文档？ 其实在工作中进行项目交付的时候经常用到；简单来说数据库文档就是对整个数据库设计说明的文档，比如使用了哪个数据库，每张表的字段，类型说明等，然后整理成一个设计文档，这个文档多种多样，最常见的就是word，有了数据库文档对以后的数据库维护，或者进行二次开发都很方便； 二 流行的数据库文档生成工具2.1 screw最近比较火的一款数据库文档生成工具目前支持如下几种数据库，其它还在开发中 MySQL MariaDB TIDB Oracle SqlServer PostgreSQL Cache DB 文档生成支持 文档生成支持 html word markdwon 生成示例 使用方式 支持 java ,和 maven 插件, java方式看官方文档； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;cn.smallbun.screw&lt;/groupId&gt; &lt;artifactId&gt;screw-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;lastVersion&#125;&lt;/version&gt; &lt;dependencies&gt; &lt;!-- HikariCP --&gt; &lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql driver--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;!--username--&gt; &lt;username&gt;root&lt;/username&gt; &lt;!--password--&gt; &lt;password&gt;password&lt;/password&gt; &lt;!--driver--&gt; &lt;driverClassName&gt;com.mysql.cj.jdbc.Driver&lt;/driverClassName&gt; &lt;!--jdbc url--&gt; &lt;jdbcUrl&gt;jdbc:mysql://127.0.0.1:3306/xxxx&lt;/jdbcUrl&gt; &lt;!--生成文件类型--&gt; &lt;fileType&gt;HTML&lt;/fileType&gt; &lt;!--打开文件输出目录--&gt; &lt;openOutputDir&gt;false&lt;/openOutputDir&gt; &lt;!--生成模板--&gt; &lt;produceType&gt;freemarker&lt;/produceType&gt; &lt;!--文档名称 为空时:将采用[数据库名称-描述-版本号]作为文档名称--&gt; &lt;fileName&gt;测试文档名称&lt;/fileName&gt; &lt;!--描述--&gt; &lt;description&gt;数据库文档生成&lt;/description&gt; &lt;!--版本--&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;!--标题--&gt; &lt;title&gt;数据库文档&lt;/title&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 项目地址： https://gitee.com/leshalv/screw 2.2 DBCHMDBCHM 支持SqlServer/MySQL/Oracle/PostgreSQL/DB2/SQLite数据库。 支持的导出的文件格式； chm word excel pdf html xml markdown 效果展示 最新版本示 DBCHM.exe 软件，上手也容易； 项目地址：https://gitee.com/lztkdr/DBCHM 2.3 TableGoTableGo是基于数据库的代码自动生成工具，低代码编程技术的实现，可以零代码自动生成SpringBoot项目工程、生成JavaBean、生成MyBaits的Mapper映射配置文件、生成数据库设计文档（Word、Excel）、生成Swagger2离线API文档、生成前后端代码、能查出数据库数据生成各种代码和文档等； 支持MySQL、Oracle、SQL Server、PostgreSQL、MariaDB五种数据库； 使用自定义模板功能可以根据数据库表结构信息生成你想要的任何代码，例如：Java、C#、C++、Golang、Rust、Python、Objective-C、Swift、VB、VC、SQL、HTML、JSP、JS、PHP、Vue、React、Word、Excel等； 界面展示： 详细介绍地址：https://blog.csdn.net/vipbooks/article/details/78767469 官网地址：http://www.tablego.cn/ 求关注关注吖","path":"2020/11/05/工具/最好用的数据库文档生成工具/","date":"11-05","excerpt":"","tags":[{"name":"高效工具","slug":"高效工具","permalink":"https://zszxz.github.io/tags/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/"}]},{"title":"Another Redis DeskTop Manager一款稳定全新的redis连接工具","text":"前言Another Redis DeskTop Manager是一款全新的，稳定，快速的redis桌面连接工具；支持Linux, windows, mac；当加载大量的key时不会发生奔溃现象； 下载地址 ： https://github.com/qishibo/AnotherRedisDesktopManager/releases 由于RDM需要收费，IDEA里的Iedis插件升级到3.0之后也要收费，所以这版 redis连接工具非常友好，免费稳定； github 下载可能很慢，可以关注 公众号 知识追寻者 后台回复 ARDM 获取软件 目前Another Redis DeskTop Manager已经更新到1.37版本；星级8.1k； 更新日志和支持特性如下： 2020-06-18: SSL/TLS支持 2020-04-28：大的键支持浏览，页面缩放，自动化json 2020-04-18: 键值格式化支持 2020-04-04：集群支持！ 2020-03-13：暗模式支持!!! &amp;&amp; JsonView在其他地方 2020-02-16：SSH私钥支持 2020-02-13：在选项卡中打开Cli控制台 2019-06-14：自定义字体家族支持 2019-05-28：密钥列表可调整大小 2019-05-09：哈希列表集Zset中的搜索支持 2019-04-26：自动更新 2019-04-09：SSH隧道连接支持 2019-04-01：提取搜索支持 2019-02-22：单连接支持 2019-01-08：项目开始 进入 我们今天的正题 语言支持Another Redis DeskTop Manager支持三种语言，分别是英语，中文简体，中文繁体；知识追寻者习惯使用英文，下文使用英文界面演示； 连接设置输入 地址host , 端口，密钥，连接名称；如下图 UI界面Another Redis DeskTop Manager 界面完全不是 Redis DeskTop Manager 能够比拟；我们可以清晰的看见key，服务器版本，使用内存，运行状态，使用到的库等信息； 改变界面颜色，知识追寻者相信小伙伴们都喜欢黑色，点击设置按钮选择 DASK MODE ; 酷黑界面展示： 功能演示选择库 通过如下方式的下拉框选择使用的库，redis一共16个库 添加key 点击 new key 按钮添加 key ,下列框可以选择key的类型（redis5种基本数据类型）； 未key 填写上内容，点击保存按钮 Another Redis DeskTop Manager支持三种文本格式，分别是 text,json , unserialize 最后知识追寻者已经替读者下载好了window 版本 和 mac版本的 客户端 可以关注 公众号 知识追寻者 后台回复 ARDM 获取软件 如果想要知识追寻者 原创pdf 和 面试题 可以后台 回复 “拍拍知识追寻者” 领取 （资源不定期更新）","path":"2020/11/05/工具/Another-Redis-DeskTop-Manager一款稳定全新的redis连接工具/","date":"11-05","excerpt":"","tags":[{"name":"高效工具","slug":"高效工具","permalink":"https://zszxz.github.io/tags/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/"}]},{"title":"自定义github主页","text":"一 前言知识追寻者本篇带来的是关于 github 如何自定义仓库展示，如何自定义 github 主页 个人形象；其实很早就想写了，抽不出空来，今天特意写了一篇，希望大家可以美化一下自己的github； 二 自定义展示仓库首先，我们需要登陆 github ； 然后点击我们的头像，选择 you proflie 选项； 然后会进入 显示列表，可以看见 显示的的一些默认的仓库；然后按如下图方式 点击 选项 自定义展示仓库； 进入自己定义仓库后可以挑选你认为 流行或者较好的项目作为展示的封面；知识追寻者这边只挑选多个； 点击确定保存后，展示如下： 三 自定义个人主页建立和账号同名的仓库，并且初始化ReadMe.md ， 在里面书写你个人经历，介绍，喜欢的事情等等； 比如我写了这样一段话 12345你好游客，欢迎来到知识追寻者的github; 知识追寻者致力于分享技术文章，构建知识图谱，帮助更多的人在自学的道路上更加轻松；如果你爱java后端技术，就关注我吧，在我的公众号上可以学习到各种技术文章， 主流面试题；当然只学技术还远远不够，我还是你们的心灵人生导师；在公众号上我还会分享一些技术以外的文章，丰富你的人生阅历；增加知识量， 强化大脑，开拓视野，成为一个独立思考的人； 保存后，我们的主页就变成了 ReadMe 文本里面的介绍‘，效果看下图；是不是很美观；当然知识追寻者没那些创意技巧，就简单写了文字；","path":"2020/11/05/分享/自定义github主页/","date":"11-05","excerpt":"","tags":[{"name":"分享","slug":"分享","permalink":"https://zszxz.github.io/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"提升工作效率100%的软件","text":"一 前言知识追寻者好久没有分享软件资源咯，做人不能太懒，我还是写出来了，怕下周没时间喵呜呜；本期的软件分享大多是知识追寻者常用的软件，提升工作效率，办公效率； 公众号：知识追寻者 知识追寻者(Inheriting the spirit of open source, Spreading technology knowledge;) 二 常用window软件2.1 potplayer这款是视频播放软件软件，网称宇宙级播放神器，单从名头上将就很响亮，内置强大的解码器，支持多种播放格式，动态设置屏幕比例，帧位；还能直播，添加字幕，音频处理，多种自定义皮肤，自定义播放速度比例等；但最好的还是没有广告，占用内存小，良心之作； 下载地址：https://daumpotplayer.com/download/ 2.2 火绒安全火绒安全几乎无广告，安全保护电脑，实时监控，病毒查杀，但知识追寻者用它的主要目的是全程拦截弹窗，年轻的时候不懂事，如果下载过一些流氓软件的就知道有弹窗有多么恶心，比如好压工具，暴风影音等等，没有弹窗的电脑体验感是真的爽； 地址： https://www.huorong.cn/ 2.3 远程登陆说到远程办公，2020年肯定好多读者都体验过，使用TeamViewer 和 向日葵软件都能远程登陆，随时随地访问远程电脑，它们之间的主要区别就是TeamViewer 有收费版，服务器在国外，网络不太稳定，安全性存在问题；向日葵广告铺天盖地，限制连接数量，清晰度存在问题；个人还是觉得向日葵会好点，比较安全免费； TeamViewer 地址： https://www.teamviewer.cn/cn/credentials/free-for-personal-use/ 向日葵地址：https://sunlogin.oray.com/ 2.4 腾讯电脑管家-桌面整理如果经常与数据，图像，文件打交道的读者就知道，满屏幕都是文件的痛苦，每天都是乱七八糟的屏幕，能有好心情才怪，腾讯桌面整理就是快速整理桌面的工具； 地址：https://guanjia.qq.com/product/zmzl/?ADTAG=media.buy.baidu 2.5 Snipaste最好用的截图软件，没有其它，自定义，截图，贴图快捷键，随意捕捉屏幕，编辑截图，略缩，透明，图片取色等，而且完全免费； 下载地址：https://www.snipaste.com/download.html 2.6 ScreenToGif视频转gif 动图，减小内存，动图制作神器；支持视频录制，转动图后压缩视频体积，完全免费； 地址：https://github.com/NickeManarin/ScreenToGif/releases 2.7 喵影工厂号称风靡全球入门级视频剪辑神器，内置多种视频剪辑素材，转场效果，音频特效等；简单易上手，想玩短视频的读者良心视频剪辑入门神器； 地址：https://miao.wondershare.cn/ 2.8 笔记知识追寻者主要使用的是有道云笔记和印象笔记，整理日常知识，规划等，简单易上手，一个程序员没有专门的笔记是不可能的，你的大脑哪里记得过来；有道云笔记免费，但是需要坚持签到才能领取免费空间，签到王者就是你啦；印象笔记空间无限，有传输限制，有收费版本； 有道云笔记地址：http://login.ynote.youdao.com/index.html 印象笔记地址：https://www.yinxiang.com/ 2.9 BandizipBandizip 是强大的解压缩工具，最新版本好像都是要收费，次版本以下都是免费，无广告，支持多种解压缩格式；知识追寻者常用软件之一；知识追寻者记得此软件有github开源版，读者可以耐心找找 地址：https://www.bandizip.com/ 今天的分享就到这里把，我是知识追寻者，我们下期再见；","path":"2020/11/05/工具/提升工作效率100-的软件/","date":"11-05","excerpt":"","tags":[{"name":"高效工具","slug":"高效工具","permalink":"https://zszxz.github.io/tags/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/"}]}],"categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://zszxz.github.io/tags/redis/"},{"name":"分享","slug":"分享","permalink":"https://zszxz.github.io/tags/%E5%88%86%E4%BA%AB/"},{"name":"数据库","slug":"数据库","permalink":"https://zszxz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"高效工具","slug":"高效工具","permalink":"https://zszxz.github.io/tags/%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7/"}]}